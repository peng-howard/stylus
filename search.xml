<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Hexo 的 NexT 主题中使用 Mathjax]]></title>
      <url>%2Fstylus%2F2017%2F03%2F28%2Fmathjax%2F</url>
      <content type="text"><![CDATA[Mathjax 指令参考：http://docs.mathjax.org/en/latest/tex.html 与Markdown的冲突解决原文地址：http://blog.csdn.net/emptyset110/article/details/50123231 hexo先用marked.js渲染，然后再交给MathJax渲染。在marked.js渲染的时候下划线_是被escape掉并且换成了&lt;em&gt;标签，即斜体字，另外LaTeX中的\\也会被转义成一个\，这样会导致MathJax渲染时不认为它是一个换行符了。 修改marked.js源码的方式来避开这些问题 针对下划线的问题，取消_作为斜体转义，因为marked.js中*也是斜体的意思，所以取消掉_的转义并不影响我们使用markdown，只要我们习惯用*作为斜体字标记就行了。 针对marked.js与Mathjax对于个别字符二次转义的问题，我们只要不让marked.js去转义\\,\{,\}在MathJax中有特殊用途的字符就行了。 具体修改方式，用编辑器打开marked.js（在./node_modules/marked/lib/中），将其中的： escape: /^\\([\\`*{}\[\]()# +\-.!_&gt;])/,1 em: /^\b_((?:[^_]|__)+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,1 替换成： escape: /^\\([`*\[\]()# +\-.!_>])/,1 em:/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/, 支持带编号的公式在原有的themes\next\layout\_third-party.mathjax.swig中添加如下内容： 1234567&lt;script type=&quot;text/x-mathjax-config&quot;&gt; MathJax.Hub.Config(&#123; TeX: &#123;equationNumbers: &#123;autoNumber: [&quot;AMS&quot;], useLabelIds: true&#125;&#125;, &quot;HTML-CSS&quot;: &#123;linebreaks: &#123;automatic: true&#125;&#125;, SVG: &#123;linebreaks: &#123;automatic: true&#125;&#125; &#125;);&lt;/script&gt; 之后可以像 LaTeX 一样添加\label{}以及\eqref{}, \ref{}。 其它内容本模板提供了一个&lt;pre class=&quot;white&quot;&gt;&lt;code&gt;...&lt;/code&gt;&lt;/pre&gt;的环境用于生成背景为白色的代码环境，注意&lt;pre&gt;与&lt;code&gt;之间可以换行，但&lt;code&gt;与文本之间要紧密相联；还提供了&lt;pre class=&quot;center&quot;&gt;&lt;/pre&gt;用于生成文字居中效果，不需要在行与行之间换行！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[谈谈 Bias-Variance Tradeoff z]]></title>
      <url>%2Fstylus%2F2017%2F03%2F25%2Fbias-variance-tradeoff%2F</url>
      <content type="text"><![CDATA[原文地址：http://liam0205.me/2017/03/25/bias-variance-tradeoff/ 准确是两个概念。准是 bias 小，确是 variance 小。准确是相对概念，因为 bias-variance tradeoff。 ——Liam Huang 在机器学习领域，人们总是希望使自己的模型尽可能准确地描述数据背后的真是规律。通俗所言的「准确」，其实就是误差小。在领域中，排除人为失误，人们一般会遇到三种误差来源：随机误差、偏差和方差。偏差和方差又与「欠拟合」及「过拟合」紧紧联系在一起。由于随机误差是不可消除的，所以此篇我们讨论在偏差和方差之间的权衡（Bias-Variance Tradeoff）。 定义数学上定义首先需要说明的是随机误差。随机误差是数据本身的噪音带来的，这种误差是不可避免的。一般认为随机误差服从高斯分布，记作 $\epsilon\sim\mathcal N(0, \sigma_\epsilon)$。因此，若有变量 $y$ 作为预测值，以及 $X$ 作为自变量（协变量），那么我们将数据背后的真实规律 $f$ 记作 $$y = f(X) + \epsilon.$$ 偏差和方差则需要在统计上做对应的定义。 偏差（bias）描述的是通过学习拟合出来的结果之期望，与真实规律之间的差距，记作 $\text{Bias}(X) = E[\hat f(X)] - f(X)$。 方差（variance）即是统计学中的定义，描述的是通过学习拟合出来的结果自身的不稳定性，记作 $\text{Var}(X) = E\Bigl[\hat f(X) - E[\hat f(X)]\Bigr]$。 以均方误差为例，有如下推论 \begin{equation} \begin{aligned} \text{Err}(X) &amp;{}= E\Bigl[\bigl(y - \hat f(X)\bigr)^2\Bigr] \\ &amp;{}= E\Bigl[\bigl(f(X) + \epsilon - \hat f(X)\bigr)^2\Bigr] \\ &amp;{}= \left(E[\hat{f}(X)]-f(X)\right)^2 + E\left[\left(\hat{f}(X)-E[\hat{f}(X)]\right)^2\right] +\sigma_\epsilon^2 \\ &amp;{}= \text{Bias}^2 + \text{Variance} + \text{Random Error}. \end{aligned} \label{eq:err-comp} \end{equation} 直观的图示下图将机器学习任务描述为一个「打靶」的活动：根据相同算法、不同数据集训练出的模型，对同一个样本进行预测；每个模型作出的预测相当于是一次打靶。 http://scott.fortmann-roe.com/docs/BiasVariance.html 左上角的示例是理想状况：偏差和方差都非常小。如果有无穷的训练数据，以及完美的模型算法，我们是有办法达成这样的情况的。然而，现实中的工程问题，通常数据量是有限的，而模型也是不完美的。因此，这只是一个理想状况。 右上角的示例表示偏差小而方差大。靶纸上的落点都集中分布在红心周围，它们的期望落在红心之内，因此偏差较小。另外一方面，落点虽然集中在红心周围，但是比较分散，这是方差大的表现。 左下角的示例表示偏差大二方差小。显而易见，靶纸上的落点非常集中，说明方差小。但是落点集中的位置距离红心很远，这是偏差大的表现。 右下角的示例则是最糟糕的情况，偏差和方差都非常大。这是我们最不希望看到的结果。 举个栗子现在我们做一个模拟实验，用以说明至此介绍的内容。 首先，我们生成了两组 array，分别作为训练集和验证集。这里，x 与 y 是接近线性相关的，而在 y 上加入了随机噪声，用以模拟真实问题中的情况。 12345678910111213import numpy as npnp.random.seed(42) # the answer to life, the universe and everythingreal = lambda x:x + x ** 0.1x_train = np.linspace(0, 15, 100)y_train = map(real, x_train)y_noise = 2 * np.random.normal(size = x_train.size)y_train = y_train + y_noisex_valid = np.linspace(0, 15, 50)y_valid = map(real, x_valid)y_noise = 2 * np.random.normal(size = x_valid.size)y_valid = y_valid + y_noise 现在，我们选用最小平方误差作为损失函数，尝试用多项式函数去拟合这些数据。 1234prop = np.polyfit(x_train, y_train, 1)prop_ = np.poly1d(prop)overf = np.polyfit(x_train, y_train, 15)overf_ = np.poly1d(overf) 这里，对于 prop，我们采用了一阶的多项式函数（线性模型）去拟合数据；对于 overf，我们采用了 15 阶的多项式函数（多项式模型）去拟合数据。如此，我们可以把拟合效果绘制成图。 12345678910111213141516171819202122232425import matplotlib.pyplot as plt_ = plt.figure(figsize = (14, 6))plt.subplot(1, 2, 1)prop_e = np.mean((y_train - np.polyval(prop, x_train)) ** 2)overf_e = np.mean((y_train - np.polyval(overf, x_train)) ** 2)xp = np.linspace(-2, 17, 200)plt.plot(x_train, y_train, '.')plt.plot(xp, prop_(xp), '-', label = 'proper, err: %.3f' % (prop_e))plt.plot(xp, overf_(xp), '--', label = 'overfit, err: %.3f' % (overf_e))plt.ylim(-5, 20)plt.legend()plt.title('train set')plt.subplot(1, 2, 2)prop_e = np.mean((y_valid - np.polyval(prop, x_valid)) ** 2)overf_e = np.mean((y_valid - np.polyval(overf, x_valid)) ** 2)xp = np.linspace(-2, 17, 200)plt.plot(x_valid, y_valid, '.')plt.plot(xp, prop_(xp), '-', label = 'proper, err: %.3f' % (prop_e))plt.plot(xp, overf_(xp), '--', label = 'overfit, err: %.3f' % (overf_e))plt.ylim(-5, 20)plt.legend()plt.title('validation set') 以训练集上的结果来说，线性模型的误差要明显高于多项式模型。站在人类观察者的角度来说，这似乎是显而易见的：数据是围绕一个近似线性的函数附近抖动的，那么用简单的线性模型，自然就无法准确地拟合数据；但是，高阶的多项式函数可以进行各种「扭曲」，以便将训练集的数据拟合得更好。 这种情况，我们说线性模型在训练集上欠拟合（underfitting），并且它的偏差（bias）要高于多项式模型的偏差。 但这并不意味着线性模型在这个问题里，要弱于多项式模型。我们看到，在验证集上，线性模型的误差要小于多项式模型的误差。并且，线性模型在训练集和验证集上的误差相对接近，而多项式模型在两个数据集上的误差，差距就很大了。 这种情况，我们说多项式模型在训练集上过拟合（overfitting），并且它的方差（variance）要高于线性模型的偏差。此外，因为线性模型在两个集合上的误差较为接近，因此我们说线性模型在训练过程中未见的数据上，泛化能力更好。因为，在真实情况下，我们都需要使用有限的训练集去拟合模型，而后工作在无限的真实样本中，而这些真实样本对于模型训练过程都是不可见的。所以，模型的泛化能力，是非常重要的指标。 考虑到两个模型在验证集上的表现，在这个任务上，我们说线性模型表现得较好。 权衡之术克服 OCD对于很多人来说，不可避免地会有这样的强迫症：希望训练误差降至 0。 我们说，人想要过得快乐，首先要接纳自己，与自己和解。做机器学习相关的任务也是一样，首先要理解和接受机器学习的基本规律，克服自己的强迫症。 首先，对于误差，在公式 \ref{eq:err-comp} 中，我们得知误差中至少有「随机误差」是无论如何不可避免的。因此，哪怕有一个模型在训练集上的表现非常优秀，它的误差是 0，这也不能说明这个模型完美无缺。因为，训练集本身存在的误差，将会被带入到模型之中；也就是说，这个模型天然地就和真实情况存在误差，于是它不是完美的。 其次，由于训练样本无法完美地反应真实情况（样本容量有限、抽样不均匀），以及由于模型本身的学习能力存在上限，也意味着我们的模型不可能是完美的。 因此，我们需要克服强迫症，不去追求训练误差为 0；转而去追求在给定数据集和模型算法的前提下的，逼近最优结果。 最佳平衡点的数学表述在实际应用中，我们做模型选择的一般方法是： 选定一个算法； 调整算法的超参数； 以某种指标选择最合适的超参数组合。 也就是说，在整个过程中，我们固定训练样本，改变模型的描述能力（模型复杂度）。不难理解，随着模型复杂度的增加，其描述能力也就会增加；此时，模型在验证集上的表现，偏差会倾向于减小而方差会倾向于增大。而在相反方向，随着模型复杂度的降低，其描述能力也就会降低；此时，模型在验证集上的表现，偏差会倾向于增大而方差会倾向于减小。 考虑到，模型误差是偏差与方差的加和，因此我们可以绘制出这样的图像。 http://scott.fortmann-roe.com/docs/BiasVariance.html 图中的最有位置，实际上是 total error 曲线的拐点。我们知道，连续函数的拐点意味着此处一阶导数的值为 0。考虑到 total error 是偏差与方差的加和，所以我们有，在拐点处： \begin{equation} \newcommand{\dif}{\mathop{}!\mathrm{d}} \frac{\dif\text{Bias}}{\dif\text{Complexity}} = - \frac{\dif\text{Variance}}{\dif\text{Complexity}} \label{eq:sweet} \end{equation} 公式 \eqref{eq:sweet} 给出了寻找最优平衡点的数学描述。若模型复杂度大于平衡点，则模型的方差会偏高，模型倾向于过拟合；若模型复杂度小于平衡点，则模型的偏差会偏高，模型倾向于过拟合。 过拟合与欠拟合的外在表现尽管有了上述数学表述，但是在现实环境中，有时候我们很难计算模型的偏差与方差。因此，我们需要通过外在表现，判断模型的拟合状态：是欠拟合还是过拟合。 同样地，在有限的训练数据集中，不断增加模型的复杂度，意味着模型会尽可能多地降低在训练集上的误差。因此，在训练集上，不断增加模型的复杂度，训练集上的误差会一直下降。 因此，我们可以绘制出这样的图像。 http://www.learnopencv.com/bias-variance-tradeoff-in-machine-learning/ 因此， 当模型处于欠拟合状态时，训练集和验证集上的误差都很高； 当模型处于过拟合状态时，训练集上的误差低，而验证集上的误差会非常高。 处理欠拟合与过拟合有了这些分析，我们就能比较容易地判断模型所处的拟合状态。接下来，我们就可以参考 Andrew Ng 博士提供的处理模型欠拟合/过拟合的一般方法了。 欠拟合当模型处于欠拟合状态时，根本的办法是增加模型复杂度。我们一般有以下一些办法： 增加模型的迭代次数； 更换描述能力更强的模型； 生成更多特征供训练使用； 降低正则化水平。 过拟合当模型处于过拟合状态时，根本的办法是降低模型复杂度。我们则有以下一些武器： 扩增训练集； 减少训练使用的特征的数量； 提高正则化水平。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[LaTeX 中的浮动体：处理超宽问题]]></title>
      <url>%2Fstylus%2F2017%2F03%2F22%2Ffloats-in-LaTeX-handle-overfull-floats%2F</url>
      <content type="text"><![CDATA[原文地址：http://liam0205.me/2017/03/22/floats-in-LaTeX-handle-overfull-floats/ 前文说了，浮动体主要是处理高度比较大，又不方便分割的内容：比如图片和表格。实际上，此类内容除了在高度上可能很高，它们也可能很宽。LaTeX 在水平方向，会贴着版芯的左边边界，开始排列内容。因此，如果一张图片或者表格的宽度超过了版芯的宽度，那么看起来就像是没有居中，而是偏右。 此篇我们讲一下如何处理此类情况。 缩小对付内容过大，最直接的办法，就是把它们缩小。对于图片，如果使用了 graphicx 宏包，我们可以使用 width = \linewidth 的参数将图片缩放到正好填满页面宽度的大小，避免「超宽」。对于表格等其他内容，我们可以使用 graphicx 提供的 \resizebox 命令来处理。 12345678910111213141516171819202122\documentclass&#123;article&#125;\usepackage&#123;showframe&#125;\usepackage&#123;graphicx&#125;\begin&#123;document&#125;\begin&#123;table&#125;[!htb]\centering\caption&#123;Oh, this table is overfull!&#125;\label&#123;tab:overfull&#125;\rule&#123;1.1\linewidth&#125;&#123;3cm&#125;\end&#123;table&#125;\begin&#123;table&#125;[!htb]\centering\caption&#123;Imagine that this is a table.&#125;\label&#123;tab:resized&#125;\resizebox&#123;\linewidth&#125;&#123;!&#125;&#123;\rule&#123;1.1\linewidth&#125;&#123;3cm&#125;&#125;\end&#123;table&#125;\begin&#123;figure&#125;[!htb]\centering\includegraphics[width = \linewidth]&#123;example-image&#125;\caption&#123;A fit figure.&#125;\label&#123;fig:example-image&#125;\end&#123;figure&#125;\end&#123;document&#125; 想办法居中上述通过缩小解决问题，是一种办法。但是，在很多情况下，也会存在问题；比如 表格内容缩小之后，就看不清了； \verb 之类的内容，不能放在大多数 box 之内。 为此，我们需要用别的办法，尝试解决这些问题。 实际上，大多数用户对于这类问题最大的诉求在于：为什么这些超宽的图表不局中了？所以，我们只要解决「居中」的问题，可能就覆盖了绝大部分用户的需求。而这些内容无法居中的原因，我们在介绍部分也说过了：LaTeX 在水平方向，会贴着版芯的左边边界，开始排列内容。因此，如果我们能让 LaTeX 不从版芯的最左边开始排列内容，就有可能解决这个问题。 决定 LaTeX 从何处开始排列内容的，是 \leftskip 这个宏。在 LaTeX2e 中，它被默认定义为 \z@。也就是说，从版芯的左边边界处开始排列内容。我们可以修改这个宏，比如改为 \setlength{\leftskip}{-20pt}，那么 LaTeX 将从版芯左边边界左边的 20pt 的位置开始排列内容。 1234567891011\documentclass&#123;article&#125;\usepackage&#123;showframe&#125;\usepackage&#123;graphicx&#125;\begin&#123;document&#125;\begin&#123;table&#125;[!htb]\centering\caption&#123;Oh, this table is overfull!&#125;\label&#123;tab:overfull&#125;\setlength&#123;\leftskip&#125;&#123;-20pt&#125;\rule&#123;1.1\linewidth&#125;&#123;3cm&#125;\end&#123;table&#125;\end&#123;document&#125; 同理，我们有 \rightskip，用于确定水平方向排版的终止位置与版芯右边界之间的距离。 我们知道，TeX 的 skip 是所谓的「弹簧」，允许在一定程度上进行缩放；而所谓的居中，实际上就是在版芯两侧，有两个力量相等的无限弹簧，同时向中间挤压内容。因此，我们不难得到对 \leftskip 和 \rightskip 的几个要求： 默认情况，应该贴着两侧边界； 最差的情况，应该允许内容向左右两侧延伸，超过版芯但不超过纸张宽度； 同时具有让内容居中的能力。 因此，我们可以将它们设置为（粗略地）： 12\setlength&#123;\leftskip&#125;&#123;0pt plus 1fil minus \marginparwidth&#125;\setlength&#123;\rightskip&#125;&#123;\leftskip&#125; 为了让它更好用，我们可以把他们收纳在一个新的命令当中（包含了一些额外的工作）： 1234567891011121314151617\documentclass&#123;article&#125;\usepackage&#123;showframe&#125;\usepackage&#123;graphicx&#125;\makeatletter\newcommand*&#123;\centerfloat&#125;&#123;% \parindent \z@ \leftskip \z@ \@plus 1fil \@minus \marginparwidth \rightskip \leftskip \parfillskip \z@skip&#125;\makeatother\begin&#123;document&#125;\begin&#123;table&#125;[!htb]\centerfloat\caption&#123;Oh, this table is adjusted!&#125;\label&#123;tab:adjusted&#125;\rule&#123;1.1\linewidth&#125;&#123;3cm&#125;\end&#123;table&#125;\end&#123;document&#125; 当然，你也可以通过 \makebox 命令来达成目标，不过这样依然无法容纳含有类似 \verb 的内容： 12345678910\documentclass&#123;article&#125;\usepackage&#123;showframe&#125;\usepackage&#123;graphicx&#125;\begin&#123;document&#125;\begin&#123;table&#125;[!htb]\centering\caption&#123;Oh, this table is adjusted!&#125;\label&#123;tab:adjusted&#125;\makebox[0pt][c]&#123;\rule&#123;1.1\linewidth&#125;&#123;3cm&#125;&#125;\end&#123;table&#125;\end&#123;document&#125; 使用 adjustbox 宏包Martin Scharrer 有发布名为 adjustbox 的宏包，提供了类似 graphicx 宏包中 \includegraphics 命令的 key-value 参数，用以实现各类 box 效果。值得一提的是，宏包提供的几个宏、环境，都可以容纳 \verb 之类的内容。很是好用。 12345678910\documentclass&#123;article&#125;\usepackage&#123;showframe&#125;\usepackage&#123;adjustbox&#125;\begin&#123;document&#125;\begin&#123;table&#125;[!htb]\centering\caption&#123;Oh, this table is adjusted by the package adjustbox!&#125;\label&#123;tab:adjusted&#125;\adjustbox&#123;center&#125;&#123;\rule&#123;1.1\linewidth&#125;&#123;3cm&#125;&#125;\end&#123;table&#125;\end&#123;document&#125; 效果和使用我们定义的 \centerfloat 命令类似，这里就不重复贴图了。 倘若把它倒过来……上面的介绍，基本都仅限于处理 overfull 程度不大、超出版芯程度不多的情形。如果你有一个大胖娃娃，他/她使得版芯宽度严重超载，那么你可能要考虑把它旋转九十度了。 rotating 宏包提供了 sidewaystable 和 sidewaysfigure 环境（以及带 * 的版本，用于在双栏模式下通栏排版），分别作为对应 table 和 figure 的工具。使用这些环境，能使图表旋转 90° 摆放。 12345678910\documentclass&#123;article&#125;\usepackage&#123;showframe&#125;\usepackage&#123;rotating&#125;\begin&#123;document&#125;\begin&#123;sidewaystable&#125;[!htb]\centering\caption&#123;Let's rock!&#125;\label&#123;tab:rotated&#125;\rule&#123;0.8\linewidth&#125;&#123;3cm&#125;\end&#123;sidewaystable&#125;\end&#123;document&#125; 需要注意的是，当旋转过来之后，「长宽」就交换了。因此，我们这里使用 0.8\linewidth 实际上是相对版芯的高度的 0.8 倍。此外，rotating 宏包默认将内容逆时针旋转了 90°，你也可以在调用宏包时传入 clockwise 参数，得到顺时针旋转的版本。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[LaTeX 中的浮动体：基础篇z]]></title>
      <url>%2Fstylus%2F2017%2F03%2F11%2Ffloats-in-LaTeX-basic%2F</url>
      <content type="text"><![CDATA[原文地址：http://liam0205.me/2017/03/11/floats-in-LaTeX-basic/ 此篇介绍一下 LaTeX 中的浮动体基本概念，以及最常见的几个问题。 浮动体是什么在实际撰写文稿的过程中，我们可能会碰到一些占据篇幅较大，但同时又不方便分页的内容。（比如图片和表格，通常属于这样的类型）此时，我们通常会希望将它们放在别的地方，避免页面空间不够而强行置入这些内容导致 overfull vbox 或者大片的空白。此外，因为被放在别的地方，所以，我们通常需要对这些内容做一个简单的描述，确保读者在看到这些大块的内容时，不至于无从下手去理解。同时，因为此类内容被放在别的地方，所以在文中引述它们时，我们无法用「下图」、「上表」之类的相对位置来引述他们。于是，我们需要对它们进行编号，方便在文中引用。 注意到，使用浮动体的根本目的是避免不合理的分页或者大块的空白，为此，我们需要将大块的内容移至别的地方。与之相辅相成的是浮动体的一些特性： 是一个容器，包含某些不可分页的大块内容； 有一个简短的描述，比如图题或者表题； 有一个编号，用于引述。 在 LaTeX 中，默认有 figure 和 table 两种浮动体。（当然，你还可以自定义其他类型的浮动体）在这些环境中，可以用 \caption{} 命令生成上述简短的描述。至于编号，也是用 \caption{} 生成的。这类编号遵循了 TeX 对于编号处理的传统：它们会自动编号，不需要用户操心具体的编号数值。 至于「别的地方」是哪里，LaTeX 为浮动体启用了所谓「位置描述符」的标记。基本来说，包含以下几种 h - 表示 here。此类浮动体称为文中的浮动体（in-text floats）。 t - 表示 top。此类浮动体会尝试放在一页的顶部。 b - 表示 bottom。此类浮动体会尝试放在一页的底部。 p - 表示 float page，浮动页。此类浮动体会尝试单独成页。 LaTeX 会将浮动体与文本流分离，而后按照位置描述符，根据相应的算法插入 LaTeX 认为合适的位置。 一个简单的实例123456789\documentclass&#123;article&#125;\begin&#123;document&#125;Figure \ref&#123;fig:dummy&#125; is a dummy figure to show the use of basic floats in \LaTeX&#123;&#125;.\begin&#123;figure&#125;[htb]\rule&#123;4cm&#125;&#123;3cm&#125; % a black box, treat it as a dummy figure\caption&#123;Dummy figure&#125;\label&#123;fig:dummy&#125;\end&#123;figure&#125;\end&#123;document&#125; 限制浮动效果有些强（chu）迫（nv）症（zuo）宝宝希望保留浮动体的标题以及编号的功能，但是希望浮动体「乖乖待在插入的位置」。 对于这些小朋友，老夫必须说：「这是病，得治」。 说它是「病」，是因为浮动效果本身是好的；相反，禁止浮动效果，可能导致页面出现大片的空白。另一方面，这些小朋友希望浮动体待在原地，很可能是习惯了「下图」、「上表」这样的引述方式；而没有使用科技论文标准的「图 1」、「表 2」的因数方式。 因此，老夫墙裂建议各位小朋友，不要管它，随它浮动去吧。 当然，在一些极端的情况，也会出现 LaTeX 无法很好地处理浮动体放置位置的情况。这时候需要我们做一些辅助工作，帮助和限制 LaTeX 的浮动算法。 如果希望避免浮动体跨过 \section 等章节标题，可以使用 placeins 宏包。它能在章节标题前，强制输出上一章节中尚未输出的浮动体。 1\usepackage[section]&#123;placeins&#125; 如果希望彻底禁止某个浮动体的浮动效果，可以使用 float 宏包提供的 H 位置选项。 123456\usepackage&#123;float&#125;% ...\begin&#123;figure&#125;[H]% ...\begin&#123;table&#125;[H]% ... 浮动体过多报错LaTeX 是有底线的上限的。LaTeX 会把所有尚未确定位置的浮动体，放入 \@freelist 中暂存。而 \@freelist 默认情况下，最多能处理 18 个浮动体。因此，在某些极端情况下，如果 LaTeX 暂时无法处理的浮动体数目超过 18 个时，就会报错。 1! LaTeX Error: Too many unprocessed floats. 此时有两种解决问题的思路： 强制输出所有尚未确定位置的浮动体，清空 \@freelist； 增强 LaTeX 的处理能力。 对于第一种思路，我们可以用 \clearpage，或者 placeins 宏包提供的 \FloatBarrier 命令。两个命令都会输出所有尚未输出的浮动体。不同的是，\clearpage 会做一些额外的工作，比如另起一页，继续排版。个人建议使用 \FloatBarrier 命令，遵循「一个命令只做好一件事」的原则。 如果使用了 \FloatBarrier 命令，还是经常会报错提示未处理的浮动体过多，那么就要考虑第二种思路了。对于第二种思路，我们可以使用 morefloats 宏包。\usepackage[morefloats = 18]{morefloats}，来增加 18 个槽位，以便能够向 \@freelist 放入更多的浮动体。 在 2015 年，David Carlisle 在新版的 LaTeX2e (2015) 中实现了 \extrafloats 命令，可以方便地新增更多的槽位。具体用法只需在导言区执行该命令即可：\extrafloats{500}。 浮动体上下的垂直距离最近总有人不爽 LaTeX 浮动体与周围文本的默认间距。LaTeX 浮动体相关的定义都可以在 source2e 当中找到，这里罗列重要的间距如下。 \floatsep - 相邻两个浮动体之间的垂直距离。 \textfloatsep - 页面中最后一个 t 模式的浮动体与文本的间距；页面中第一个 b 模式的浮动体与文本的间距。 \intextsep - 页面中共 h 模式的浮动体上下与文本的间距。 因此，你可以通过 \setlength 命令修改上述三个垂直距离，以便调整浮动体与前后文本的距离了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[调和曲线图和轮廓图的比较z]]></title>
      <url>%2Fstylus%2F2013%2F07%2F15%2Fparallel-coordinate-plot-andrews-curves%2F</url>
      <content type="text"><![CDATA[原文地址：http://cos.name/2009/03/parallel-coordinates-and-andrews-curve/#more-704 作者：魏太云 多元数据的可视化方法很多，譬如散点图、星图、雷达图、脸谱图、协同图等，大致可分为以下几类： 基于点（如二维、三维散点图）； 基于线（如轮廓图、调和曲线图）； 基于平面图形（如星图、雷达图、蛛网图）； 基于三维曲面（如三维曲面图）。 其思想是将高维数据映射到低维空间（三维以下）内，尽量使信息损失最少，同时又能利于肉眼辨识。调和曲线图和轮廓图(即平行坐标图)都是多元数据的可视化方法，它们基于“线”的形式，将多元数据表示出来，对于聚类分析有很好的帮助。 轮廓图轮廓图的思想非常简单、直观，它是在横坐标上取$p$个点，依次表示各个指标(即变量)；横坐标上则对应各个指标的值(或者经过标准化变换后的值)，然后将每一组数据对应的点依次连接即可。 lattice包中的parallel()函数可以轻松绘出轮廓图。利用iris数据，以下代码可以画出其轮廓图。 1234library(lattice)data(iris)parallel(~iris[1:4], iris, groups = Species, horizontal.axis = FALSE, scales = list(x = list(rot = 90))) .png?psid=1) 图1 Iris 数据的轮廓图(Parallel Coordinate Plots) 观察上图，可以发现同一品种的鸢尾花的轮廓图粗略地聚集在一起。 调和曲线图调和曲线图的思想和傅立叶变换十分相似，是根据三角变换方法将$p$维空间的点映射到二维平面上的曲线上。假设$X_r$是$p$维数据的第$r$个观测值，即 $$X_r^T=(x_{r1},\dotsc,x_{rp})$$ 则对应的调和曲线是 $$f_r(t)=\frac{x_{r1}}{\sqrt{2}} +x_{r2}\sin t+x_{r3}\cos t+x_{r4}\sin 2 t+x_{r5} \cos 2 t+\cdots$$ 其中$-\pi\leqslant t\leqslant \pi$. 同样利用iris数据，下面代码(主要取自《统计建模与R软件》，尚未优化)可以画出其调和曲线图 12345678910111213141516171819x = as.matrix(iris[1:4])t = seq(-pi, pi, pi/30)m = nrow(x)n = ncol(x)f = matrix(0, m, length(t))for (i in 1:m) &#123; f[i, ] = x[i, 1]/sqrt(2) for (j in 2:n) &#123; if (j%%2 == 0) f[i, ] = f[i, ] + x[i, j] * sin(j/2 * t) else f[i, ] = f[i, ] + x[i, j] * cos(j%/%2 * t) &#125;&#125;plot(c(-pi, pi), c(min(f), max(f)), type = "n", main = "The Unison graph of Iris", xlab = "t", ylab = "f(t)")for (i in 1:m) lines(t, f[i, ], col = c("red", "green3", "blue")[unclass(iris$Species[i])])legend(x = -3, y = 15, c("setosa", "versicolor", "virginica"), lty = 1, col = c("red", "green3", "blue")) 图2 Iris 数据的调和曲线图 观察上图，同样可以发现同一品种鸢尾花数据的调和曲线图基本上扭在一起。同第一幅图比较后，发现第二幅图更加清楚明白，事实上Andrews证明了调和曲线图有许多良好性质。 讨论轮廓图和调和曲线图有着相近的功能，而技巧大有不同。轮廓图简单却现得粗糙，调和曲线图公式复杂却十分精细。从这一个侧面可以发现直观的统计思想固然重要，但存在很多种不可能通过直观思想得到的、而又非常精细、美妙的方法，此时倍受众多统计学家责难的数学显得优雅而又强大。 谢益辉：正好我前一段时间也写过一个调和曲线图的R函数，发出来分享一下： 123456789101112131415161718192021andrews.curve = function(x, n = 101, type = "l", lty = 1, lwd = 1, pch = NA, xlab = "t", ylab = "f(t)", ...) &#123; p = ncol(x) if (is.null(p)) stop("'x' must be a matrix or data.frame!") if (p &lt; 1) stop("'x' must have at least one column!") theta = matrix(seq(-pi, pi, length.out = n), nrow = n, ncol = 1) if (p == 1) &#123; a = matrix(x/sqrt(2), nrow = n, ncol = nrow(x), byrow = TRUE) &#125; if (p &gt; 1) &#123; b = matrix(rep(1:(p/2), each = 2, length.out = p - 1), nrow = 1, ncol = p - 1) a = cbind(1/sqrt(2), sin(theta %*% b + matrix(rep(c(0, pi/2), length.out = p - 1), nrow = n, ncol = p - 1, byrow = TRUE))) %*% t(x) &#125; matplot(theta, a, type = type, lty = lty, lwd = lwd, pch = pch, xlab = xlab, ylab = ylab, ...)&#125; 里面都是以矩阵的形式做的运算，不过我没有测试，不知道速度会不会快一些。对于调和曲线图，观测$X_i$和$X_j$的欧式距离正好是曲线垂直距离的积分，这是数学性质和图形性质能够结合的关键。 魏太云：快很多呢，没有一个显式循环，十分方便:)。调和曲线图的确很好地将数学融进了图形，可谓鬼斧神工啊。 fasterr：andrews.curve(x, col=c(‘red’, ‘green3′, ‘blue’))可是画出来的不是很一样：《统计建模与R软件》版的调和曲线的颜色比较友好，相近族类的颜色一样、不同类的颜色不同。 andrews.curve()绘制的曲线颜色是是交替的（一次red，一次green3, 一次blue，依次循环使用），而不是颜色按类聚集，这样画出来的色彩整体很凌乱（颜色重叠后就更变味了）。 传入什么控制参数andrews.curve()也能得到一样的效果么？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[滤波的基本概念]]></title>
      <url>%2Fstylus%2F2013%2F07%2F10%2Ffilter%2F</url>
      <content type="text"><![CDATA[参考资料： 滤波(filter)：http://baike.baidu.com/view/162707.htm 增益(gain)：http://baike.baidu.com/view/343150.htm 低通滤波(Low-pass filter)：http://baike.baidu.com/view/1669798.htm 高通滤波(high-pass filter)：http://baike.baidu.com/view/1877222.htm 1 滤波 滤波是将信号中特定波段频率滤除的操作，是抑制和防止干扰的一项重要措施。分经典滤波和现代滤波。 滤波是将信号中特定波段频率滤除的操作，是抑制和防止干扰的一项重要措施。是根据观察某一随机过程的结果，对另一与之有关的随机过程进行估计的概率理论与方法。 1.1 起源滤波一词起源于通信理论，它是从含有干扰的接收信号中提取有用信号的一种技术。“接收信号”相当于被观测的随机过程，“有用信号”相当于被估计的随机过程。例如用雷达跟踪飞机，测得的飞机位置的数据中，含有测量误差及其他随机干扰，如何利用这些数据尽可能准确地估计出飞机在每一时刻的位置、速度、加速度等，并预测飞机未来的位置，就是一个滤波与预测问题。这类问题在电子技术、航天科学、控制工程及其他科学技术部门中都是大量存在的。历史上最早考虑的是维纳滤波，后来R.E.卡尔曼和R.S.布西于20世纪60年代提出了卡尔曼滤波。现对一般的非线性滤波问题的研究相当活跃。 1.2 经典滤波经典滤波的概念，是根据傅立叶分析和变换提出的一个工程概念。根据高等数学理论，任何一个满足一定条件的信号，都可以被看成是由无限个正弦波叠加而成。换句话说，就是工程信号是不同频率的正弦波线性叠加而成的，组成信号的不同频率的正弦波叫做信号的频率成分或叫做谐波成分。 滤波器 只允许一定频率范围内的信号成分正常通过，而阻止另一部分频率成分通过的电路，叫做经典滤波器或滤波电路。实际上，任何一个电子系统都具有自己的频带宽度(对信号最高频率的限制)，频率特性反映出了电子系统的这个基本特点。而滤波器，则是根据电路参数对电路频带宽度的影响而设计出来的工程应用电路。 1.3 现代滤波用模拟电子电路对模拟信号进行滤波，其基本原理就是利用电路的频率特性实现对信号中频率成分的选择。根据频率滤波时，是把信号看成是由不同频率正弦波叠加而成的模拟信号，通过选择不同的频率成分来实现信号滤波。 当允许信号中较高频率的成分通过滤波器时，这种滤波器叫做高通滤波器。 当允许信号中较低频率的成分通过滤波器时，这种滤波器叫做低通滤波器。 设低频段的截止频率为fp1，高频段的截止频率为fp2: 频率在fp1与fp2之间的信号能通过其它频率的信号被衰减的滤波器叫做带通滤波器。 反之，频率在fp1到fp2的范围之间的被衰减，之外能通过的滤波器叫做带阻滤波器。 理想滤波器的行为特性通常用幅度-频率特性图描述，也叫做滤波器电路的幅频特性。 滤波问题及分类对于滤波器，增益幅度不为零的频率范围叫做通频带，简称通带，增益幅度为零的频率范围叫做阻带。例如对于LP，从-w1到w1之间，叫做LP的通带，其他频率部分叫做阻带。通带所表示的是能够通过滤波器而不会产生衰减的信号频率成分，阻带所表示的是被滤波器衰减掉的信号频率成分。通带内信号所获得的增益，叫做通带增益，阻带中信号所得到的衰减，叫做阻带衰减。在工程实际中，一般使用dB作为滤波器的幅度增益单位。 按照滤波是在一整段时间上进行或只是在某些采样点上进行，可分为连续时间滤波与离散时间滤波。前者的时间参数集$T$可取为实半轴$[0,\infty)$或实轴$(-\infty,\infty)$;后者的$T$可取为非负整数集$\{0,1,2,\dotsc\}$或整数集$\{\dotsc,-2,-1,0,1,2,\dotsc\}$。设$X=\{X_t\in T={Y,t\in T)$有穷，即其中$X$为被估计过程，它不能被直接观测；$Y$为被观测过程，它包含了$X$的某些信息。用表示到时刻$t$为止的观测数据全体，如果能找到中诸元的一个函数?(),使其均方误差达到极小，就称为$X_t$的最优滤波；如果取极小值的范围限于线性函数，就称为$X_t$的线性最优滤波。可以证明，最优滤波与线性最优滤波都以概率1惟一存在。对于前者，悯t就是$X_t$关于$\sigma()$(生成的$\sigma$域)的条件期望，记作对于后者，若进一步设均值$E(X_t)$呏$(EY_t)$呏0,则悯t就是$X_t$在所张成的希尔伯特空间上的投影，记作如果$(X,Y)$是二维正态过程，则最优滤波与线性最优滤波是一致的。这部分有错 为了应用和叙述的方便，有时还把上面的定义更细致地加以分类。设$\tau$为一确定的实数或整数，且考虑被估计过程。按照$\tau=0,\tau&gt;0,\tau&lt;0$，分别称为最优滤波、($\tau$步)预测或外推、($\tau$步)平滑或内插，分别为对应的误差与均方误差，而统称这类问题为滤波问题。滤波问题的主要课题是研究对哪些类型的随机过程$X$和$Y$，可以并且如何用观测结果的某种解析表示式，或微分方程，或递推公式等形式,表达出并进而研究它们的种种性质。此外，上面所指的一维随机过程$X,Y$，都可以推广为多维随机过程。 维纳滤波历史上最先考虑的是宽平稳过程(见平稳过程)的线性预测和滤波问题，它的一般模型是$Y_t=X_t+N_t$，其中$(X，N)$为二维宽平稳过程或序列，其谱分布函数已知，其均值为零。设从$-\infty$到时刻$t$为止的全部$Y$的值都已被观测到，求$X$的$\tau$步线性预测及其均方误差。如果限于考虑$N=0,\tau&gt;0$的情形，则变成在无误差观测条件下$X$本身的线性预测问题；如果$N\neq 0,\tau\leqslant 0$，则变成从受到噪声$N$干扰的接收信号$Y$中提取有用信号$X$的滤波问题。1939$\sim$1941年，Α.Η.柯尔莫哥洛夫利用平稳序列的沃尔德分解(见平稳过程)，给出了线性预测的一般理论与处理办法，随即被推广到连续时间的平稳过程。N.维纳则在1942年对于平稳序列与过程的谱密度存在且满足某种正则条件的情形，利用谱分解导出了线性最优预测和滤波的明显表达式，即维纳滤波公式，并在防空火力控制、电子工程等部门获得了应用。上述模型在50年代被推广到仅在有限时间区间内进行观测的平稳过程以及某些特殊的非平稳过程，其应用范围也扩充到更多的领域。至今它仍是处理各种动态数据（如气象、水文、地震勘探等）及预测未来的有力工具之一。 维纳滤波公式是通过平稳过程的谱分解导出的，难以推广到较一般的非平稳过程和多维情形，因而应用范围受到限制。另一方面，在不断增加观测结果时，不易从已算出的滤波值及新的观测值较简单地求出新的滤波值，特别是不能满足在电子计算机上快速处理大量数据的需要。 卡尔曼滤波由于高速电子计算机的发展以及测定人造卫星轨道和导航等技术问题的需要，R.E.卡尔曼与R.S.布西于20世纪60年代初期提出了一类新的线性滤波的模型与方法，通称为卡尔曼滤波。其基本假设是，被估计过程$X$为随机噪声影响下的有限阶多维线性动态系统的输出，而被观测的$Y_t$则是$X_t$的部分分量或其线性函数与量测噪声的叠加，这里并不要求平稳性，但要求不同时刻的噪声值是不相关的。此外，观测只需从某一确定时刻开始，而不必是无穷长的观测区间。更重要的是，适应电子计算机的特点，卡尔曼滤波公式不是将估计值表成观测值的明显的函数形式，而是给出它的一种递推算法(即实时算法)。具体地说，对于离散时间滤波，只要适当增大$X$的维数，就可以将$t$时刻的滤波值表成为前一时刻的滤波值与本时刻的观测值$Y_t$的某种线性组合。对于连续时间滤波,则可以给出与$Y_t$所应满足的线性随机微分方程。在需要不断增加观测结果和输出滤波值的情形，这样的算法加快了处理数据的速度，而且减少了数据存贮量。卡尔曼还证明，如果所考虑的线性系统满足某种“可控性”和“可观测性”(这是现代控制理论中由卡尔曼提出的两个重要概念)，那么最优滤波一定是“渐近稳定”的。大致说来，就是由初始误差、舍入误差及其他的不准确性所引起的效应，将随着滤波时间的延长而逐渐消失或趋于稳定， 不致形成误差的积累。这在实际应用上是很重要的。 卡尔曼滤波也有多种形式的推广，例如放宽对噪声不相关性的限制，用线性系统逼近非线性系统，以及所谓“自适应滤波”，等等，并获得了日益广泛的应用。 非线性滤波前已说明，一般的非线性最优滤波可归结为求条件期望的问题。对于有限多个观测值的情形，条件期望原则上可以用贝叶斯公式来计算。但即使在比较简单的场合，这样得出的结果也是相当繁杂的，无论对实际应用或理论研究都很不方便。与卡尔曼滤波类似，人们也希望能给出非线性滤波的某种递推算法或它所满足的随机微分方程。但一般它们并不存在，因此必须对所讨论的过程X与Y加以适当的限制。非线性滤波的研究工作相当活跃，它涉及随机过程论的许多近代成果，如随机过程一般理论、鞅、随机微分方程、点过程等。其中一个十分重要的问题，是研究在什么条件下，存在一个鞅M，使得在任何时刻,M和Y都包含同样的信息；这样的M称为Y的新息过程。目前对于一类所谓“条件正态过程”，已经给出了非线性最优滤波的可严格实现的递推算式。在实际应用上，对非线性滤波问题往往采用各种线性近似的方法。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[散点图与回归拟合线]]></title>
      <url>%2Fstylus%2F2013%2F07%2F05%2Fscatter-fitted-line%2F</url>
      <content type="text"><![CDATA[在初级的计量教材中看到一幅用Eviews制作的散点图，这幅图的最大特点是在X-Y散点图中还加入了回归拟合线。这种类型的图我知道用Excel是很容易制作的，在网上查询的结果也有其他人考虑过在Stata, SAS, SPSS, R等软件中来完成。 我曾经一度非常希望能够通过Eviews内带的命令来完成这一幅图的制作，但似乎没有特别简洁的做法。现在想起来，其实这种图没什么太大意义，毕竟现实工作中很少会出现一元回归的场合。 不过从另一角度来看，这种图或许在分位数回归中有些许实用性，毕竟即使解释变量只有一个的情形下，这种类型的图也可以让初学者更清楚的看到平均值回归与分位数回归的差异所在。 Eviews的作图功能太弱，R、Stata等都能最方便的得到想要的图形。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[分位点与分位数 z]]></title>
      <url>%2Fstylus%2F2013%2F06%2F25%2Fquantile%2F</url>
      <content type="text"><![CDATA[分位数在统计学是中一个比较简单和容易理解的概念，大部分初级的统计学教材中都会有相应的介绍。但实际在理解这个概念的时候，要注意连续情形下与分位数相关的几个概念之间的联系与区别。 离散情形举一个例子，将100名同学的期末考试总分成绩所组成的向量$\mathbf{x}$按从小到大的规则进行排序，生成一个新的顺序统计量$\mathbf{x}^\prime$，那么$\mathbf{x}$的$1/4$分位数指的是$\mathbf{x}^\prime$第25号位上的那个数字，同理可知中位数以及$3/4$分位数等。 连续情形以正态分布为例，$1/4$分位数指的是$\mathrm{Pr}(X\leqslant x)=1/4$对应的$x$值，类似的，标准正态分布中中位数对应的$x$为0。 从上面的例子可以看出，分位点确定的基础是在离散情形下将样本数量标准化为1，而在连续情形下则是将x坐标轴的可用长度标准化为1(对于正态分布和t分布而言，原始长度为$-\infty$到$+\infty$之间的全部范围。 在连续情形下，若考虑的置信系数是左单侧的，那么置信系数$\alpha$对应的下$\alpha$分位点的$x$值与$\alpha$分位数以及$\mathrm{Pr}(X\leqslant x)=\alpha$中的$x$实际上指向同一个$x$值。 这个值在大部分统计软件中对应的命令以q开头，比如R中的qnorm命令。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[R的应用领域包介绍z]]></title>
      <url>%2Fstylus%2F2013%2F06%2F09%2Fr-packages-introduction%2F</url>
      <content type="text"><![CDATA[Analysis of Pharmacokinetic Data 药物(代谢)动力学数据分析 网址：http://cran.r-project.org/web/views/Pharmacokinetics.html 维护人员：Suzette Blanchard 版本：2008-02-15 翻译：R-fox, 2008-04-12 药物(代谢)动力学数据分析的主要目的是用非线性浓度时间曲线(concentration time curve)或相关的总结(如曲线下面积)确定给药方案(dosing regimen)和身体对药物反应间的关系。R基本包里的nls()函数用非线性最小二乘估计法估计非线性模型的参数，返回nls类的对象，有coef(), formula(), resid(), print(), summary(), AIC(), fitted(), vcov()等方法。 在主要目的实现后，兴趣就转移到研究属性(如：年龄、体重、伴随用药、肾功能)不同的人群是否需要改变药物剂量。在药物(代谢)动力学领域，分析多个个体的组合数据估计人群参数被称作群体药动学(population PK)。非线性混合模型为分析群体药动学数据提供了自然的工具，包括概率或贝叶斯估计方法。 nlme包用Lindstrom和Bates提出的概率方法拟合非线性混合效应模型(1990, Biometrics 46, 673-87)，允许nested随机效应(nested random effects)，组内误差允许相关的或不等的方差。返回一个nlme类的对象表示拟合结果，结果可用print(), plot()和summary()方法输出。nlme对象给出了细节的结果信息和提取方法。 nlmeODE包组合odesolve包和nlme包做混合效应建模，包括多个药动学/药效学(PK/PD)模型。 面版数据(panel data)的贝叶斯估计方法在CRAN的Bayesian Inference任务列表里有所描述(http://cran.r-project.org/web/views/Bayesian.html)。 PKtools包为nlme, NONMEM和WinBUGS包提供单剂量群体药动学数据的接口，分别返回&quot;PKNLME&quot;，&quot;NONMEM&quot;和&quot;WinBUGS&quot;类的对象；促进了混合似然和贝叶斯方法的使用。PKtools包的其它函数有：AICcomp()函数从NONMEM和nlme计算模型的AIC, AICc (small sample AIC)和对数似然值。paramEst()和indEst()分别返回群体和个体参数，对NONMEM类使用最大似然法，对nlme类使用广义最小二乘法，对WinBUGS类使用MCMC贝叶斯估计法。HTMLtools()和tex()函数分别输出群体和个体参数的HTML和LaTeX报道文件，和诊断图(diagnostic plot)便于用户选择估计方法。还能分别产生HTMLtools和tex文件里的诊断图。 其它的分析药物(代谢)动力学数据的包还有： PK, PKfit和drc。VR包束的MASS包包括一些基本的方法，如：计算Logit或Probit模型的半数致死计量LD50。 分析药物(代谢)动力学数据的图形展示也非常重要，lattice包的trellis图用来可视化面板数据。 计算计量经济学(Computational Econometrics) 网址：http://cran.r-project.org/web/views/Econometrics.html 维护人员：Achim Zeileis 版本：2008-04-02 翻译：R-fox, 2008-04-15 R的很多基本函数都可用于计量经济学，尤其是stats包。CRAN的许多包也有可以分析计量经济学，下面做个简要的综述。这里介绍的工具可能与CRAN的计量金融(empirical finance)任务列表(http://cran.r-project.org/web/views/Finance.html)有许多的重合。此外，从邮件列表finance SIG(https://www.stat.math.ethz.ch/mailman/listinfo/R-SIG-Finance/)可获得计量经济和计量金融相关的帮助和讨论问题。CRAN的Social Sciences任务列表(http://cran.r-project.org/web/views/SocialSciences.html)覆盖了许多社会科学的工具，因此也与这里的工具有所重合，如：政治科学。这里综述的包大致可分为如下的几个话题： 线形回归模型(Linear regression models) 线形模型可由lm()函数拟合，也有各种检验方法用来比较模型，如：summary() 和anova()。类似的函数也支持。类似的功能也适合于渐近检验(如：z检验而不是t检验，卡方检验而不是F检验)，此外还有lmtest包里的coeftest()和waldtest()函数。car包里的linear.hypothesis()可检验更广义的线形假设。HC和HAC协方差矩阵的这些功能可在sandwich包里实现。car和lmtest包还提供了许多线形回归模型的诊断方法。 微观计量经济学(Microeconometrics)： 许多微观计量经济学模型属于广义线形模型，可由stats包的glm()函数拟合。包括用于选择类数据(choice data)的Logit和probit模型，用于计数类数据(count data)的poisson模型。负二项广义线形模型可由MASS包的glm.nb()实现。边缘(zero—inflated)和hurdle计数模型可由pscl包提供，zicounts包里也实现了边缘模型。双变量Poisson回归模型可在bivpois包里实现。基本的删失回归模型(censored regression model)，如：tobit模型，可由survival包里的survreg()函数拟合。micEcon包里提供了微观计量经济学的更好的工具。bayesm包执行微观计量济学和营销学(marketing)中的贝叶斯方法。reldist包提供了相对分布(relative distributions)相关的方法。 其它的回归模型(Further regression models)： R和CRNA包里有各种延伸的线形回归模型和其它模型拟合方法。非线性最小二乘回归建模可用stats包里的nls()实现。相关的包还有：quantreg(分位数回归Quantile Regression)，crq(截取分位点回归censored quantile regression)，plm(面板数据的线形回归)，sem(线性结构方程模型，包括二阶段最小平方)，systemfit(联立方程估计)，np(非参核方法)，betareg(beta回归)，nlme(非线性混合效应模型)，VR(nnet 包的多项Logit模型)，MNP(贝叶斯多项Probit模型)。Design和Hmisc包提供广义线形回归模型的工具。 基本的时间序列架构(Basic time series infrastructure)： stats包的&quot;ts&quot; 类是R的规则间隔时间序列的标准类。Zoo包提供了规则和不规则间隔时间序列的架构。建立在&quot;POSIXt&quot;时间-日期类上的its, tseries和fCalendar包也提供不规则间隔时间序列的架构，特别用于金融分析。 时间序列建模(Time series modelling)： stats包里有经典的时间序列建模工具，arima()函数做ARIMA建模和Box-Jenkins-type分析。stats包还提供StructTS()函数拟合结构时间序列，decompose()过滤时间序列，HoltWinters()分解时间序列。forecasting包束提供了一些延伸的方法，尤其是预测和模型选择。多种时间序列的过滤器可在mFilter包里找到。为了估计VAR模型，stats包的ar()拟合简单的模型，vars包、dse包的estVARXls()提供了更精巧的模型，MSBVAR包提供了贝叶斯方法。Dynlm包提供了经由OLS过滤动态回归模型的方便接口；dyn包里则提供了不同的方法。更高级的动态系统方程可由dse包拟合。高斯线形状态空间模型可由dlm包拟合(用最大斯然，kalman滤波/平滑，和贝叶斯方法)。Unit root(单位根)和cointegration technique(协整技术)可在urca，uroot和tseries包里找到。tsfa包可做时间序列因子分析。sde包提供随机微分方程的模拟和推论。 矩阵处理(Matrix manipulations)： 作为一个向量和矩阵语言，R有许多基本函数处理矩阵，与Matrix和SparseM包互补。 放回再抽样(Bootstrap)： 除了推荐的boot包，bootstrap或simpleboot包里有一些其它的常规bootstrapping技术；还有些函数专门为时间序列数据而设计，如：meboot包里的最大熵bootstrap，tseries包里的tsbootstrap()函数。 不平等(Inequality)： 为了测量不平等(inequality)，集中(concentration)和贫穷(poverty)，ineq包提供了一些基本的工具，如：劳伦茨曲线(Lorenz curves)，Pen&#39;s parade，基尼系数(Gini coefficient)。 结构变化(Structural change)： R有很强的处理参数模型的结构变化和变化点的能力，可参考strucchange和segmented包。 数据集(Data sets)： 这里介绍的许多包里都有来自计量经济学文献里的数据集，Ecdat包包括许多来自计量经济学教科书和杂志(应用计量经济学，商业/经济统计)的数据集。FinTS包针对书&#39;Analysis of Financial Time Series&#39; (2nd ed., 2005, Wiley)，包括数据集，函数，列子的脚本文件。CDNmoney包提供加拿大货币流通额，pwt包提供佩恩世界表(Penn World Table)。 R空间分析很高兴看到R在生态学里的众多应用，我是生态学的外行，但也想来凑下热闹。希望越来越多的人喜欢R(http://www.r-project.org/)，喜欢R语言中文论坛(http://rbbs.biosino.org/Rbbs/forums/list.page)。下面根据CRAN的介绍资料综述一下R分析空间数据的功能(http://cran.r-project.org/web/views/Spatial.html；http://r-spatial.sourceforge.net/；http://sal.uiuc.edu/csiss/Rgeo/)，仅仅是翻译总结资料，有不对的地方请批评指正。 R分析空间数据(Spatial Data)的包主要包括两部分： 导入导出空间数据 分析空间数据 功能及函数包： 分类空间数据(Classes for spatial data)： 包sp(http://cran.r-project.org/web/packages/sp/index.html)为不同类型的空间数据设计了不同的类，如：点(points)，栅格(grids)，线(lines)，环(rings)，多边形(polygons)。另外sp提供总结数据，获取坐标等功能；提供画图函数，并且允许在图上添加空间元素(spatial elements)和参考元素(reference elements)，如：比例尺(scale bar)，指北针(north arrows)等。现在很多包都利用了sp包中的类，如：rgdal, maptools。 处理空间数据(Handling spatial data)： spsurvey包提供做概率抽样的函数(http://cran.r-project.org/web/packages/spsurvey/index.html)；trip包扩展sp包的类，针对动物跟踪数据(http://cran.r-project.org/web/packages/trip/index.html)；hdeco包用等级分解熵比较类型地图(categorical map)(http://cran.r-project.org/web/packages/hdeco/index.html)；GeoXp包允许交互式的分析空间数据(http://cran.r-project.org/web/packages/GeoXp/index.html)。 读写空间数据(Reading and writing spatial data)： 图像有向量式绘图和光栅式两种。Rgdal可以读入和导出GDAL支持的光栅式格式(http://www.gdal.org/)和OGR(http://www.gdal.org/ogr/)支持的向量格式(http://cran.r-project.org/web/packages/rgdal/index.html)。ncdf包用来处理NetCDF文件(http://cran.r-project.org/web/packages/ncdf/index.html)；maps包可连接一些地理学数据库并展示地理图(http://cran.r-project.org/web/packages/maps/index.html)；RArcInfo包可读取ArcInfo v.7二进制文件和*.e00文件()；maptools包管理和读入地理数据，也为PBSmapping包、spatsta包和sp类提供接口函数(http://cran.r-project.org/web/packages/maptools/index.html)，还可以通到GSHHS数据库；classInt包为专题地图制图选择单变量的类间距(http://cran.r-project.org/web/packages/classInt/index.html)；gmt包提供R和GMT绘图软件的接口(http://cran.r-project.org/web/packages/gmt/index.html)。 点格局分析(Point pattern analysis)： spatstat包做空间点分布型态(Spatial Point Patterns)分析，长处在于模型拟合和仿真(http://cran.r-project.org/web/packages/spatstat/index.html)；spatgraphs包提供点格局的可视化图形(http://cran.r-project.org/web/packages/spatgraphs/index.html)；splancs包允许分析多边形区域，包括很多种方法，如：2维核密度(http://cran.r-project.org/web/packages/splancs/index.html)；ecespa包提供书《Introduccion al Analisis Espacial de Datos en Ecologia y Ciencias Ambientales: Metodos y Aplicaciones》里用的点格局分析函数和数据(http://cran.r-project.org/web/packages/ecespa/index.html)；aspace包计算空间中心统计(centrographic satistics)和最小凸多边形(http://cran.r-project.org/web/packages/aspace/index.html)；spatialkernel包做多元数据的非参核密度估计和核回归估计(http://cran.r-project.org/web/packages/spatialkernel/index.html)。 地质统计学(Geostatistics) ： gstat包做单变量和多变量地质统计，适合于大的数据集(http://cran.r-project.org/web/packages/gstat/index.html)；geoR包(用贝叶斯模型，http://cran.r-project.org/web/packages/geoR/index.html)和geoRglm包(用线性模型，http://cran.r-project.org/web/packages/geoRglm/index.html)做基于模型的地质统计；fields包也提供许多类似的函数(http://cran.r-project.org/web/packages/fields/index.html)；spBayes包用蒙特卡洛一马尔科夫链方法(MCMC)做单变量和多变量的高斯模型(http://cran.r-project.org/web/packages/spBayes/index.html)。 RandomFields包模拟和分析随机场(http://cran.r-project.org/web/packages/RandomFields/index.html)；tripack包用于不规则数据的三角测量法(http://cran.r-project.org/web/packages/tripack/index.html)；akima包用于不规则数据的线性或三次样条插值(http://cran.r-project.org/web/packages/akima/index.html)；spatialCovariance包计算矩形数据的空间协方差矩阵(http://cran.r-project.org/web/packages/spatialCovariance/index.html)……。 疾病制图和地区数据分析(Disease mapping and areal data analysis)： DCluster包用计数数据探测疾病的空间聚类，计算空间权重，测试空间自相关，建立空间回归模型等(http://cran.r-project.org/web/packages/DCluster/index.html)；spgwr包做地理加权回归模型，检测平稳性(http://cran.r-project.org/web/packages/spgwr/index.html)；spatclus包(http://cran.r-project.org/web/packages/spatclus/index.html)。spatclus包探测2维或3维空间点分布的任意形状的聚类(http://cran.r-project.org/web/packages/spatclus/index.html)。 生态学分析(Ecological analysis)： R有很多分析生态和环境数据的包。如：grasp包用GAM模型(灰色代数曲线型模型)做环境预报(http://cran.r-project.org/web/packages/grasp/index.html)；ade4包用做环境科学里的探索和欧几里德方法(http://cran.r-project.org/web/packages/ade4/index.html)；adehabitat包分析动物的栖息地选择(http://cran.r-project.org/web/packages/adehabitat/index.html)；pastecs包做时空序列的分解和分析(http://cran.r-project.org/web/packages/pastecs/index.html)；vegan包做群落和植被生态学中的排序方法(http://cran.r-project.org/web/packages/vegan/index.html)；WeedMap包做空间预测(http://cran.r-project.org/web/packages/WeedMap/index.html)；clustTool包做聚类分析(http://cran.r-project.org/web/packages/clustTool/index.html)。更多资料见：http://cran.r-project.org/web/views/Environmetrics.html。 Multivariate Statistics (多元统计) 网址：http://cran.r-project.org/web/views/Multivariate.html 维护人员：Paul Hewson 版本：2008-02-08 翻译：R-fox, 2008-04-04 基本的R包已经实现了传统多元统计的很多功能，然而CRNA的许多其它包提供了更深入的多元统计方法，下面做个简要的综述。多元统计的特殊应用在CRNA的其它任务列表(task view)里也会提及，如：排序(ordination)会在Environmetrics(http://cran.r-project.org/web/views/Environmetrics.html)里说到；有监督的分类方法能在Machine Learning(http://cran.r-project.org/web/views/MachineLearning.html)里找到；无监督的分类在Cluster(http://cran.r-project.org/web/views/Cluster.html)里。 这里要综述的包主要分为以下几个部分： 多元数据可视化(Visualising multivariate data)： 绘图方法： 基本画图函数(如：pairs()、coplot())和lattice包里的画图函数(xyplot(), splom())可以画成对列表的二维散点图，3维密度图。car包里的scatterplot.matrix()函数提供更强大的二维散点图的画法。cwhmisc包集合里的cwhplot包的pltSplomT()函数类似pair()画散点图矩阵，而且可以在对角位置画柱状图或密度估计图。除此之外，scatterplot3d包可画3维的散点图，aplpack包里bagplot()可画二变量的boxplot，spin3R()可画可旋转的三维点图。misc3d包有可视化密度的函数。YaleToolkit包提供许多多元数据可视化技术，agsemisc也是这样。更特殊的多元图包括：aplpack包里的faces()可画Chernoff’s face；MASS包里的parcoord()可画平行坐标图(矩阵的每一行画一条线，横轴表示矩阵的每列)；graphics包里的stars()可画多元数据的星状图(矩阵的每一行用一个星状图表示)。ade4包里的mstree()和vegan包里的spantree()可画最小生成树。calibrate包支持双变量图和散点图，chplot包可画convex hull图。geometry包提供了和qhull库的接口，由convexhulln()可给出相应点的索引。ellipse包可画椭圆，也可以用plotcorr()可视化相关矩阵。denpro包为多元可视化提供水平集树形结构(level set trees)。graphics包里的mosaicplot()和vcd包里的mosaic()函数画马赛克图(mosaic plot)。gclus包提供了针对聚类的散点图和平行坐标图。rggobi包和DescribeDisplay包是GGobi的接口，DescribeDisplay的图可达到出版质量的要求；xgobi包是XGobi和XGvis的接口，可实现动态交互的图。最后，iplots包提供强大的动态交互图，尤其是平行坐标图和马赛克图。seriation包提供seriation方法，能重新排列矩阵和系统树。 数据预处理： AIS包提供多元数据的初步描述函数。Hmisc包里的summarize()和summary.formula()辅助描述数据，varclus()函数可做聚类，而dataRep()和find.matches()找给定数据集的典型数据和匹配数据。KnnFinder包里的nn()函数用kd-tree找相似变量的个数。dprep包为分类提供数据预处理和可视化函数，如：检查变量冗余性、标准化。base包里的dist()和cluster包里的daisy()函数提供距离计算函数；proxy包提供更多的距离测度，包括矩阵间的距离。simba包处理已有数据和缺失数据，包括相似性矩阵和重整形。 假设检验(Hypothesis testing)： ICSNP包提供霍特林(Hotellings)T2检验和许多非参检验方法，包括基于marginal ranks的位置检验(location test)，计算空间中值和符号，形状估计。cramer包做两样本的非参检验，SpatialNP可做空间符号和秩检验。 多元分布(Multivariate distributions)： 描述统计(Descriptive measures)： stats包里的cov()和cor()分别估计协方差和相关系数。ICSNP包提供几种数据描述方法，如：spatial.median()估计空间中值，其它的函数估计scatter。MASS包里的cov.rob()提供更健壮的方差/协方差矩阵估计。covRobust包用最近邻方差估计法估计协方差。robustbase包的covMCD()估计协方差和covOGK()做Orthogonalized Gnanadesikan-Kettenring。rrcov包提供可扩展和稳健的估计函数covMcd(), covMest()。corpcor包可计算大规模的协方差和偏相关矩阵。 密度估计和模拟(Densities (estimation and simulation))： MASS包的mvrnorm()产生多元正态分布的随机数。Mvtnorm包有多元t分布和多元正态分布的概率和分位数函数，还可计算多元正态分布的密度函数。mvtnormpcs包提供基于Dunnett的函数。mnormt包提供元t分布和多元正态分布的密度和分布函数，并可产生随机数。sn包提供多元偏t分布和偏正态分布的密度、分布、随机数函数。delt包提供了许多估计多元密度的函数方法，如：CART和贪婪方法。CRAN的Cluster任务列表(http://cran.r-project.org/web/views/Cluster.html)有更全面的信息，ks包里的rmvnorm.mixt()和dmvnorm.mixt()函数产生随机数和估计密度，bayesm包里有多种拟合方法。很多地方都提供了模拟Wishart分布的函数，如：bayesm包里的rwishart()，MCMCpack包里的rwish()，而且MCMCpack包还有密度函数dwish()。KernSmooth包里的bkde2D()和MASS包的kde2d()做分箱(binned)或不分箱二维核密度估计。ks包也像ash和GenKern包样可做核平滑(kernel smoothing)。prim包用法找高维多元数据的高密度区域，feature包可计算多元数据的显著特征。 正态检验(Assessing normality)： mvnormtest包提供Shapiro-Wilks检验的多元数据延伸方法，mvoutlier包检测多元离群点(outlier)，ICS包可检验多元正态分布。energy包里的mvnorm.etest()基于E统计量做正态检验，k.sample()检验多个数据是否来自同一分布。dprep包里的mardia()用Mardia检验正态性。stats包里的mauchly.test()可检验Wishart分布的协方差矩阵。 连接函数(Copulas)： copula包提供常规的copula函数的程序，包括：normal, t, Clayton, Frank, Gumbel。fgac包提供generalised archimedian copula，mlCopulaSelection包可做二变量的copula。 线形模型(Linear models)： stats包里的lm()可做多元线形模型，anova.mlm()比较多个多元线形模型，manova()做多元方差分析(MANOVA)。sn包的msn.mle()和mst.mle()可拟合多元偏正态和偏t分布模型。pls包提供偏最小二乘回归(PLSR)和主成分回归；ppls包可做惩罚偏最小二乘回归；dr包提供降维回归方法，如片逆回归法(Sliced Inverse Regression)、片平均方差估计(sliced average variance estimation)。plsgenomics包做基于偏最小二乘回归的基因组分析。relaimpo包可评估回归参数的相对重要性。 投影方法(Projection methods)： 主成分(Principal components)： stats包的prcomp()(基于svd())和princomp()(基于eigen())能计算主成分。sca包做单分量分析。nFactors可评价碎石图(Scree plot)，paran包可评估主成分分析得到的主成分和因子分析得到的因子。pcurve包做主曲线(Principal Curve)分析和可视化。gmodels包提供适合大矩阵的fast.prcomp()和fast.svd()。kernlab包里的kpca()用核方法做非线性的主成分分析。pcaPP包用投影寻踪(projection pursuit)法计算稳健/鲁棒(robust)主成分。amap包的acpgen()和acprob()函数分别针对广义(generalized)和稳健(robust)主成分分析。主成分在很多方面也有相应的应用，如：涉及生态的ade4包，感官的SensoMinR包。psy包里有用于心理学的各种程序，与主成分相关的有：sphpca()用球形直观表示相关矩阵，类似于3D的PCA；fpca()图形展示主成分分析的结果，而且允许某些变量间有相关性；scree.plot()图形展示相关或协方差矩阵的特征值。PTAk包做主张量分析(Principal Tensor Analysis)。smatr包提供关于异速生长(allometry)的函数。 典型相关(Canonical Correlation)： stats包里的cancor()是做典型相关的函数。kernlab包提供更稳健的核方法kcca()。concor包提供了许多concordance methods。 冗余度分析(Redundancy Analysis)： calibrate包里的rda()函数可做冗余度分析和典型相关。fso包提供了模糊集排序(Ordination)方法。 独立成分(Independent Components)： fastICA包用fastICA算法做独立成分分析(ICA)和投影寻踪分析(Projection Pursuit)，mlica包提供独立成分分析的最大似然拟合，PearsonICA包用基于互信息的打分函数分离独立信号。ICS包能执行不变坐标系(invariant coordinate system)和独立成分分析(independent components)。JADE包提供就JADE算法的接口，而且可做一些ICA。 普鲁克分析(Procrustes analysis)： vegan包里的procrustes()可做普鲁克分析，也提供排序(ordination)函数。更一般的普鲁克分析可由FactoMineR包里的GPA()实现。 主坐标/尺度方法(Principal coordinates / scaling methods)： stats包的cmdscale()函数执行传统的多维尺度分析(multidimensional scaling，MDS)(主坐标分析Principal Coordinates Analysis)，MASS包的sammon()和isoMDS()函数分别执行Sammon和Kruskal非度量多维尺度分析。vegan包提供非度量多维尺度分析的包装(wrappers)和后处理程序。 无监督分类(Unsupervised classification)： 聚类分析： CRAN的Cluster任务列表全面的综述了R实现的聚类方法。stats里提供等级聚类hclust()和k-均值聚类kmeans()。cluster包里有大量的聚类和可视化技术，clv包里则有一些聚类确认程序，e1071包的classAgreement()可计算Rand index比较两种分类结果。Trimmed k-means聚类分析可由trimcluster包实现，聚类融合方法(Cluster Ensembles)由clue包实现，clusterSim包能帮助选择最佳的聚类，hybridHclust包提供一些混合聚类方法。energy包里有基于E统计量的距离测度函数edist()和等级聚类方法hclust.energy()。LLAhclust包提供基于似然(likelihood linkage)方法的聚类，也有评定聚类结果的指标。fpc包里有基于Mahalanobis距离的聚类。clustvarsel包有多种基于模型的聚类。模糊聚类(fuzzy clustering)可在cluster包和hopach包里实现。Kohonen包提供用于高维谱(spectra)或模式(pattern)的有监督和无监督的SOM算法。clusterGeneration包帮助模拟聚类。CRAN的Environmetrics任务列表里也有相关的聚类算法的综述。mclust包实现了基于模型的聚类，MFDA包实现了功能数据的基于模型的聚类。 树方法： CRAN的MachineLearning任务列表有对树方法的细节描述。分类树也常常是重要的多元方法，rpart包正是这样的包，rpart.permutation包还可以做rpart()模型的置换(permutation)检验。TWIX包的树可以外部剪枝。hier.part包分割多元数据集的方差。mvpart包可做多元回归树，party包实现了递归分割(recursive partitioning)，rrp包实现了随机递归分割。caret包可做分类和回归训练，进而caretLSF包实现了并行处理。kknn包的k-近邻法可用于回归，也可用于分类。 有监督分类和判别分析(Supervised classification and discriminant analysis)： MASS包里的lda()和qda()分别针对线性和二次判别分析。mda包的mda(), fda()允许混合和更灵活的判别分析，mars()做多元自适应样条回归(multivariate adaptive regression splines)，bruto()做自适应样条后退拟合(adaptive spline backfitting)。earth包里也有多元自适应样条回归的函数。rda包可用质心收缩法(shrunken centroids regularized discriminant analysis)实现高维数据的分类。VR的class包的knn()函数执行k-最近邻算法，knncat包里有针对分类变量的k-最近邻算法。SensoMineR包的FDA()用于因子判别分析。许多包结合了降维(dimension reduction)和分类。klaR包可以做变量选择，可处理多重共线性，还有可视化函数。superpc包利用主成分做有监督的分类，classPP包则可为其做投影寻踪(projection pursuit)，gpls包用广义偏最小二乘做分类。hddplot包用交叉验证的线性判别分析决定最优的特征个数。supclust包可以根据芯片数据做基因的监督聚类。ROCR提供许多评估分类执行效果的方法。predbayescor包可做朴素贝叶斯(na&iuml;ve Bayes)分类。关于监督分类的更多信息可以看MachineLearning任务列表。 对应分析(Correspondence analysis)： MASS包的corresp()和mca()可以做简单和多重对应分析。ca包提供单一、多重和联合(joint)对应分析。ade4包的ca()和mca()分别做一般的和多重对应分析。vegan包里也有类似的函数。cocorresp可实现两个矩阵间的co-correspondence分析。FactoMineR包的CA()和MCA()函数也能做类似的简单和多重对应分析，还有画图函数。homals执行同质分析(homogeneity)。 前向查找(Forward search)： Rfwdmv包执行多元数据的前向查找。 缺失数据(Missing data)： mitools包里有缺失数据的多重估算(multiple imputation)的函数, mice包用chained equations实现了多重估算，mvnmle包可以为多元正态数据的缺失值做最大似然估计(ML Estimation)，norm包提供了适合多元正态数据的估计缺失值的期望最大化算法(EM algorithm)，cat包允许分类数据的缺失值的多重估算，mix包适用于分类和连续数据的混合数据。pan包可为面版数据(panel data)的缺失值做多重估算。VIM包做缺失数据的可视化和估算。Hmisc包的aregImpute()和transcan()提供了其它的估算缺失值方法。EMV包提供了knn方法估计缺失数据。monomvn包估计单调多元正态数据的缺失值。 隐变量方法(Latent variable approaches)： stats包的factanal()执行最大似然因子分析，MCMCpack包可做贝叶斯因子分析。GPArotation包提供投影梯度(Gradient Projection)旋转因子法。FAiR包用遗传算法作因子分析。ifa包可用于非正态的变量。sem包拟合线形结构方程模型。ltm包可做隐含式语义分析 (Latent semantic analysis)，eRm包则可拟合Rasch模型(Rasch models)。FactoMineR包里有很多因子分析的方法，包括：MFA()多元因子分析，HMFA()等级多元因子分析，ADFM()定量和定性数据的多元因子分析。tsfa包执行时间序列的因子分析。poLCA包针对多分类变量(polytomous variable)做潜类别分析(Latent Class Analysis)。 非高斯数据建模(Modelling non-Gaussian data)： bivpois包建模Poisson分布的二变量。mprobit包提供了适合二元和顺序响应变量的多元概率模型。MNP包实现了Bayesian多元概率模型。polycor包可计算多组相关(olychoric correlation)和四分相关(tetrachoric correlation)矩阵。bayesm包里有多种模型，如：表面非相关回归(Seemingly unrelated Regression)，多元logit/probit模型, 工具变量法(Instrumental Variables)。VGAM包里有：广义线形和可加模型(Vector Generalised Linear and Additive Models)，减秩回归(Reduced Rank regression)。 矩阵处理(Matrix manipulations)： R作为一种基于向量和矩阵的语言，有许多处理矩阵的强有力的工具，由包Matrix和SparseM实现。matrixcalc包增加了矩阵微积分的功能。spam包提供了更深入的针对稀疏矩阵的方法。 其它(Miscellaneous utitlies)： DEA包执行数据包络分析(data envelopment analysis,DEA)。abind包组合多维array。Hmisc包的mApply()扩充了apply()的功能。除了前面描述的功能，sn包还未偏正态和偏t分布提供边缘化(marginalisation)、仿射变换(affine transformations)等。SharedHT2包执行芯片数据的Hotelling&#39;s T2检验。panel包里有面版数据(panel data)的建模方法。mAr包可做向量自回归模型(vector auto-regression)，MSBVAR包里有贝叶斯向量自回归模型。Hmisc包的rm.boot()函数bootstrap重复测量试验(Repeated Measures Models)。compositions包提供复合数据分析(compositional data analysis)。cramer包为两样本数据做多元非参Cramer检验。psy里有许多心理学的常用方法。cwhmisc包集合的cwhmath包里有许多有趣的功能，如各种旋转函数。desirability包提供了基于密度函数的多变量最优化方法。geozoo包可以画geozoo包里定义的几何对象。 Machine Learning &amp; Statistical Learning (机器学习 &amp; 统计学习) 网址：http://cran.r-project.org/web/views/MachineLearning.html 维护人员：Torsten Hothorn 版本：2008-02-18 18:19:21 翻译：R-fox, 2008-03-18 机器学习是计算机科学和统计学的边缘交叉领域，R关于机器学习的包主要包括以下几个方面： 神经网络(Neural Networks)： nnet包执行单隐层前馈神经网络，nnet是VR包的一部分(http://cran.r-project.org/web/packages/VR/index.html)。 递归拆分(Recursive Partitioning)： 递归拆分利用树形结构模型，来做回归、分类和生存分析，主要在rpart包(http://cran.r-project.org/web/packages/rpart/index.html)和tree包(http://cran.r-project.org/web/packages/tree/index.html)里执行，尤其推荐rpart包。Weka里也有这样的递归拆分法，如：J4.8, C4.5, M5，包Rweka提供了R与Weka的函数的接口(http://cran.r-project.org/web/packages/RWeka/index.html)。 party包提供两类递归拆分算法，能做到无偏的变量选择和停止标准：函数ctree()用非参条件推断法检测自变量和因变量的关系；而函数mob()能用来建立参数模型(http://cran.r-project.org/web/packages/party/index.html)。另外，party包里也提供二分支树和节点分布的可视化展示。mvpart包是rpart的改进包，处理多元因变量的问题(http://cran.r-project.org/web/packages/mvpart/index.html)。rpart.permutation包用置换法(permutation)评估树的有效性(http://cran.r-project.org/web/packages/rpart.permutation/index.html)。knnTree包建立一个分类树，每个叶子节点是一个knn分类器(http://cran.r-project.org/web/packages/knnTree/index.html)。LogicReg包做逻辑回归分析，针对大多数自变量是二元变量的情况(http://cran.r-project.org/web/packages/LogicReg/index.html)。maptree包(http://cran.r-project.org/web/packages/maptree/index.html)和pinktoe包(http://cran.r-project.org/web/packages/pinktoe/index.html)提供树结构的可视化函数。 随机森林(Random Forests)：randomForest包提供了用随机森林做回归和分类的函数(http://cran.r-project.org/web/packages/randomForest/index.html)。ipred包用bagging的思想做回归，分类和生存分析，组合多个模型(http://cran.r-project.org/web/packages/ipred/index.html)。party包也提供了基于条件推断树的随机森林法(http://cran.r-project.org/web/packages/party/index.html)。varSelRF包用随机森林法做变量选择(http://cran.r-project.org/web/packages/varSelRF/index.html)。 Regularized and Shrinkage Methods：lasso2包(http://cran.r-project.org/web/packages/lasso2/index.html)和lars包(http://cran.r-project.org/web/packages/lars/index.html)可以执行参数受到某些限制的回归模型。elasticnet包可计算所有的收缩参数(http://cran.r-project.org/web/packages/elasticnet/index.html)。glmpath包可以得到广义线性模型和COX模型的L1 regularization path(http://cran.r-project.org/web/packages/glmpath/index.html)。penalized包执行lasso (L1)和ridge (L2)惩罚回归模型(penalized regression models)(http://cran.r-project.org/web/packages/penalized/index.html)。pamr包执行缩小重心分类法(shrunken centroids classifier)(http://cran.r-project.org/web/packages/pamr/index.html)。earth包可做多元自适应样条回归(multivariate adaptive regression splines)(http://cran.r-project.org/web/packages/earth/index.html)。 Boosting : gbm包(http://cran.r-project.org/web/packages/gbm/index.html)和boost包(http://cran.r-project.org/web/packages/boost/index.html)执行多种多样的梯度boosting算法，gbm包做基于树的梯度下降boosting，boost包包括LogitBoost和L2Boost。GAMMoost包提供基于boosting的广义相加模型(generalized additive models)的程序(http://cran.r-project.org/web/packages/GAMMoost/index.html)。mboost包做基于模型的boosting(http://cran.r-project.org/web/packages/mboost/index.html)。 支持向量机(Support Vector Machines)：e1071包的svm()函数提供R和LIBSVM的接口 (http://cran.r-project.org/web/packages/e1071/index.html)。kernlab包为基于核函数的学习方法提供了一个灵活的框架，包括SVM、RVM……(http://cran.r-project.org/web/packages/kernlab/index.html) 。klaR包提供了R和SVMlight的接口(http://cran.r-project.org/web/packages/klaR/index.html)。 贝叶斯方法(Bayesian Methods)： BayesTree包执行Bayesian Additive Regression Trees (BART)算法(http://cran.r-project.org/web/packages/BayesTree/index.html，http://www-stat.wharton.upenn.edu/~edgeorge/Research_papers/BART%206--06.pdf)。tgp包做Bayesian半参数非线性回归(Bayesian nonstationary, semiparametric nonlinear regression)(http://cran.r-project.org/web/packages/tgp/index.html)。 基于遗传算法的最优化(Optimization using Genetic Algorithms)：gafit包(http://cran.r-project.org/web/packages/gafit/index.html)和rgenoud包(http://cran.r-project.org/web/packages/rgenoud/index.html)提供基于遗传算法的最优化程序。 关联规则(Association Rules)：arules包提供了有效处理稀疏二元数据的数据结构，而且提供函数执Apriori和Eclat算法挖掘频繁项集、最大频繁项集、闭频繁项集和关联规则(http://cran.r-project.org/web/packages/arules/index.html)。 模型选择和确认(Model selection and validation)：e1071包的tune()函数在指定的范围内选取合适的参数(http://cran.r-project.org/web/packages/e1071/index.html)。ipred包的errorest()函数用重抽样的方法(交叉验证，bootstrap)估计分类错误率(http://cran.r-project.org/web/packages/ipred/index.html)。svmpath包里的函数可用来选取支持向量机的cost参数C(http://cran.r-project.org/web/packages/svmpath/index.html)。ROCR包提供了可视化分类器执行效果的函数，如画ROC曲线(http://cran.r-project.org/web/packages/ROCR/index.html)。caret包供了各种建立预测模型的函数，包括参数选择和重要性量度(http://cran.r-project.org/web/packages/caret/index.html)。caretLSF包(http://cran.r-project.org/web/packages/caretLSF/index.html)和caretNWS(http://cran.r-project.org/web/packages/caretNWS/index.html)包提供了与caret包类似的功能。 统计学习基础(Elements of Statistical Learning)：书《The Elements of Statistical Learning: Data Mining, Inference, and Prediction》(http://www-stat.stanford.edu/~tibs/ElemStatLearn/)里的数据集、函数、例子都被打包放在ElemStatLearn包里(http://cran.r-project.org/web/packages/ElemStatLearn/index.html)。 背景介绍： Weka：Weka有两种意思：一种不会飞的鸟的名字，一个机器学习开源项目的简称(Waikato Environment for Knowledge Analysis，http://www.cs.waikato.ac.nz/~ml/weka/)。我们这里当然要介绍的是第二种意思啦，Weka项目从1992年开始，由新西兰政府支持，现在已在机器学习领域大名鼎鼎。Weka里有非常全面的机器学习算法，包括数据预处理、分类、回归、聚类、关联规则等。Weka的图形界面对不会写程序的人来说非常方便，而且提供“KnowledgeFlow”功能，允许将多个步骤组成一个工作流。另外，Weka也允许在命令行执行命令。 R：R就不用我废话了吧，呵呵，越来越受欢迎的统计软件(http://www.r-project.org/)。 R与Weka：R里有很多机器学习的函数和包，不过Weka里提供的函数更全面更集中，所以我有时候需要用到Weka。以前我是这样用R和Weka的： 在R中准备好训练的数据(如：提取数据特征……)； 整理成Weka需要的格式(*.arff)； 在Weka里做机器学习(如：特征选择、分类……)； 从Weka的预测结果计算需要的统计量(如：sensitivity, specificity, MCC……)。 来回捣腾两个软件还是挺麻烦的；为了偷懒，我没学Weka的命令行，只会用图形界面的，在数据量大的时候非常受罪，有时候还会内存不够。现在发现R竟然提供了和Weka的接口函数包RWeka，以后方便多了哦，下面介绍一下RWeka的功能： RWeka (http://cran.r-project.org/web/packages/RWeka/index.html)： 数据输入和输出 WOW()：查看Weka函数的参数。 Weka_control()：设置Weka函数的参数。 read.arff()：读Weka Attribute-Relation File Format (ARFF)格式的数据。 write.arff：将数据写入Weka Attribute-Relation File Format (ARFF)格式的文件。 数据预处理 Normalize()：无监督的标准化连续性数据。 Discretize()：用MDL(Minimum Description Length)方法，有监督的离散化连续性数值数据。 分类和回归 IBk()：k最近邻分类 LBR()：naive Bayes法分类 J48()：C4.5决策树算法(决策树在分析各个属性时，是完全独立的)。 LMT()：组合树结构和Logistic回归模型，每个叶子节点是一个Logistic回归模型，准确性比单独的决策树和Logistic回归方法要好。 M5P()：M5 模型数算法，组合了树结构和线性回归模型，每个叶子节点是一个线性回归模型，因而可用于连续数据的回归。 DecisionStump()：单层决策树算法，常被作为boosting的基本学习器。 SMO()：支持向量机分类 AdaBoostM1()：Adaboost M1方法。-W参数指定弱学习器的算法。 Bagging()：通过从原始数据取样(用替换方法)，创建多个模型。 LogitBoost()：弱学习器采用了对数回归方法,学习到的是实数值 MultiBoostAB()：AdaBoost 方法的改进，可看作AdaBoost和“wagging”的组合。 Stacking()：用于不同的基本分类器集成的算法。 LinearRegression()：建立合适的线性回归模型。 Logistic()：建立logistic回归模型。 JRip()：一种规则学习方法。 M5Rules()：用M5方法产生回归问题的决策规则。 OneR()：简单的1-R分类法。 PART()：产生PART决策规则。 聚类 Cobweb()：这是种基于模型方法，它假设每个聚类的模型并发现适合相应模型的数据。不适合对大数据库进行聚类处理。 FarthestFirst()：快速的近似的k均值聚类算法 SimpleKMeans()：k均值聚类算法 XMeans()：改进的k均值法，能自动决定类别数 DBScan()：基于密度的聚类方法，它根据对象周围的密度不断增长聚类。它能从含有噪声的空间数据库中发现任意形状的聚类。此方法将一个聚类定义为一组“密度连接”的点集。 关联规则 Apriori()：Apriori是关联规则领域里最具影响力的基础算法，是一种广度优先算法，通过多次扫描数据库来获取支持度大于最小支持度的频繁项集。它的理论基础是频繁项集的两个单调性原则：频繁项集的任一子集一定是频繁的；非频繁项集的任一超集一定是非频繁的。在海量数据的情况下，Apriori 算法的时间和空间成本非常高。 Tertius()：Tertius算法。 预测和评估 predict()：根据分类或聚类结果预测新数据的类别 table()：比较两个因子对象 evaluate_Weka_classifier()：评估模型的执行，如：TP Rate，FP Rate，Precision，Recall，F-Measure]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Disqus与Mathjax可能有冲突]]></title>
      <url>%2Fstylus%2F2013%2F06%2F03%2Fconflict-between-disqus-and-mathjax%2F</url>
      <content type="text"><![CDATA[在系统中添加Mathjax支持的时候，发现如果LaTeX公式与Disqus评论系统同时存在，会导致如下的错误 This page is forcing your browser to use legacy mode, which is not compatible with Disqus. Please see our troubleshooting guide to get more information about this error. 这个错误在IE8.0中出现，但在Firefox 21中却不存在，初步怀疑是Mathjax调用Mootools 1.4.5而导致，具体见http://wordpress.org/support/topic/disqus-browser-legacy-error。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Math version `bold' is not defined]]></title>
      <url>%2Fstylus%2F2013%2F04%2F26%2FMath-version-bold-not-defined%2F</url>
      <content type="text"><![CDATA[使用 Y &amp; Y Mathtime 字体，用 XeLaTeX 编译，提示： “Error: Math version `bold&apos; is not defined.” 解决方法是在导言区添加： \DeclareMathVersion{bold}]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[导致“Missing number, treated as zero”的原因]]></title>
      <url>%2Fstylus%2F2013%2F02%2F01%2Fmissing-number-treated-as-zero%2F</url>
      <content type="text"><![CDATA[从http://web.mit.edu/ghudson/dev/nokrb/third/tetex/texmf/doc/help/faq/uktug-faq/FAQ271.html给出的结果看，遇到如下的情况时： ! Missing number, treated as zero. \relax l.21 \begin{Ventry}{Return values} 很可能添加calc宏包的支持就可能可以解决问题，至少我确实解决了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Matlab中的eval与feval函数]]></title>
      <url>%2Fstylus%2F2012%2F12%2F07%2Fmatlab-eval-feval%2F</url>
      <content type="text"><![CDATA[eval函数用法简介原文地址：http://www.ilovematlab.cn/thread-53554-1-1.html eval(expression)用于执行其参数中包含的expression。例如，把August1.mat到August3.mat加载到MATLAB workspace： 1234for d=1:3 s = ['load August' int2str(d) '.mat'] eval(s)end 上面的部分代码也可以写成s = [&#39;load August&#39;, int2str(d), &#39;.mat&#39;]，也就是中间用逗号隔开，这样才能把三部分合成一个字符串，以下是被执行的s语句： 123456s = load August1.mats = load August2.mats = load August3.mat feval函数用法简介原文地址：http://www.madio.net/thread-170200-1-1.html [y1,..,yn] = FEVAL(F,x1,...,xn)，F是需要使用函数的函数名，或者句柄(见下面程序注释)；xi是函数的参数，yi是函数的返回值。 举例，假设需要调用的函数foo定义如下： 12function x=foo(a,b)x=a*b; 若在main函数中用feval调用foo，可以有以下几种方式： result=feval(&#39;foo&#39;,3,15); result=feval(@foo,3,16); % 这里@foo是函数foo的句柄 若调用的函数要作为main的参数，则 12function result=main(f)result=feval(f,3,10); 然后调用main时将&#39;foo&#39;传入即可： 1&gt;&gt;main('foo'); feval和eval的区别原文地址：http://powerelite.blog.163.com/blog/static/42965891201272725641245/ feval和eval运行区别之一：feval的FN不能是表达式，其FN只接受函数名。函数eval给MATLAB提供宏的能力，该函数提供了将用户创建的函数名传给其它函数能力，以便求值。函数feval与eval类似，但在用法上有更多的限制。feval(&#39;fun&#39;,x)求由字符串&#39;fun&#39;给定的函数值，其输入参量是变量x，即feval_r(&#39;fun&#39;,x)等价于求fun(x)值，注意下面代码中的运行错误解决方法见上面feval函数的三种使用方法。 12345678format shortx=pi/4;Ve=eval('1+sin(x)') Ve = 1.7071 Vf=feval('1+sin(x)',x) ??? Error using ==&gt; fevalInvalid function name '1+sin(x)'. 关于带参数的积分问题原文地址：http://forum.chinavib.com/thread-42369-1-1.html 有不少人常问带参数的积分问题该如何处理,现举一个例子，希望能起到抛砖引玉的作用。 123456789101112131415%%%--------------------------------------------%%%例如以下问题:函数为 y=sin(k.*x).*x.^2，对x积分，积分区域为【1，5】，目的是要画 k 和 y 的图形.%%%============================================%%%%%% 作k的一个循环, k作为 inline函数的参数即可.clear allk=linspace(0,5);for i=1:length(k) kk=k(i); fun=strcat('sin(',num2str(kk),'*x).*x.^2'); y(i)=quadl(inline(fun),1,5);endplot(k,y)%%%============================================%%% 注意：这个程序的特别意义在于，对于任何复杂的、无显式积分表达式的带参数积分问题具有通用性，我主要是针对此而写的。 Matlab中函数调用及feval函数，带参数积分问题原文地址：http://www.ilovematlab.cn/thread-36666-1-1.html 123456789101112131415161718192021222324252627282930313233343536373839404142function InlineSubAnonymousNestedDemo% 带参数的积分问题% 例如% 函数为 y=sin(k.*x).*x.^2，对x积分，% 积分区域为【1，5】，目的是要画 k 和 y 的图形.% 例子意义在于,对于一些复杂的、无显式积分表达式的带参数积分问题具有通用性% 问题来源于振动论坛原xjzuo版主发的一个帖子；% 原帖地址：http://www.chinavib.com/forum/thread-42369-1-2.html%% 用inline解决tic;k=linspace(0,5);y1 = zeros(size(k));for i=1:length(k) kk=k(i); fun=inline(['sin(',num2str(kk),'*x).*x.^2']); y1(i)=quadl(fun,0,5);endtime = toc;disp(['用inline方法的时间是：',num2str(time),'秒!'])%% 用anonymous function 解决tic;f=@(k) quadl(@(x) sin(k.*x).*x.^2,0,5);kk=linspace(0,5);y2=zeros(size(kk));for ii=1:length(kk)y2(ii)=f(kk(ii));endtime = toc;disp(['用anonymous function方法的时间是：',num2str(time),'秒!'])%% 用nested function解决function y = ParaInteg(k)y=quadl(@(x) sin(k.*x).*x.^2 ,0,5);endtic;kk=linspace(0,5);y3=zeros(size(kk));for ii=1:length(kk)y3(ii)=ParaInteg(kk(ii));endtime = toc;disp(['用nested function方法的时间是：',num2str(time),'秒!'])%% 用 arrayfun + anonymous function 解决tic;y4 = arrayfun(@(k) quadl(@(x) sin(k.*x).*x.^2,0,5),linspace(0,5));time = toc;disp(['用arrayfun + anonymous function方法的时间是：',num2str(time),'秒!'])plot(kk,y2);end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[R中字符串处理和grep的用法z]]></title>
      <url>%2Fstylus%2F2012%2F12%2F05%2Fr-string-grep%2F</url>
      <content type="text"><![CDATA[原文地址：http://jliblog.com/archives/26 R通常被用来进行数值计算比较多，字符串处理相对较少，而且关于字符串的函数也不多，用得多的就是substr、strsplit、paste、regexpr这几个了。实际上R关于字符串处理的功能是非常强大的，因为它甚至可以直接使用Perl的正则表达式，这也是R的一个理念，作为语言就把向量计算做到极致，作为环境，就在各领域都集成最好的。R中有grep系列的函数，可以用最强大的方式处理字符串的所有问题。 grep的全称是global search regular expression and print out the line，是Unix下一种强大的文本搜索工具，可以通过正则表达式搜索文本，并把匹配的行打印出来，包括grep、egrep和fgrep（egrep是扩展的grep，fgrep是快速的搜寻方式并没有真正利用正则表达式）。Linux下使用GNU版的grep，该套规范也被广泛地使用，R中的grep函数就是其中之一。 grep的核心就是正则表达式（Regular Expressions，通常缩写为regex），所谓正则表达式，就是用某种模式去匹配一类字符串的一个公式，很多文本编辑器或者程序语言都支持该方式进行字符串的操作，最开始是由上文介绍的Unix工具grep之类普及的，后来得到广泛应用。尤其是Perl语言中将正则表达式发挥到了极致。 R中的正则表达式非常专业，从grep系列函数的参数就可以看出，有个参数“extended”，默认为T，表示使用扩展grep，也就是egrep，如果选择为F就表示基础的grep，不过该种方式不被R推荐，即使使用了也会出现警告，实际上grep能做的egrep也都能做，而且还要简单不少。我刚开始在egrep中使用总是不能通过，后来发现其实egrep中更简单，很多时候直接写在[]内就行。还有一个参数“perl”，默认为F，如果选择T表示使用Perl的正则表达式规则，功能更加强大，不过如果没有专门学过Perl语言的话用egrep也就够了。另一个参数“fixed”虽然描述的不是同一个东西，但是也很相关，选择之后就会进行精确的匹配，不再使用正则表达式的规则，在效率上会快很多，我觉得这个可能就是fgrep。R的帮助文档中也明确说明了这三个参数实际上代表了四种模式，常规grep、扩展grep、Perl正则表达式、精确匹配，使用者可以根据具体的含义选择自己需要的，如果参数设置互有冲突，会自动忽略后面的参数，并会在Warning中明确指出。 grep系列函数其实包括grep、grepl、sub、gsub、regexpr、gregexpr，他们的参数很类似，在R中也是把帮助文档集成在了一起，查找任意一个都会得到一个统一的文档。里面对各个参数也是一起介绍的，除了刚才说的三个以外，第一个参数就是最重要的“pattern”，这是一个字符串，直接表示正则表达式，根据模式的不同注意规则就行，另外有个“x”表示要查找的向量，这也是R中的独特之处，不是查找文件，而是查找向量，该处也可以只输入一个字符串，就成了基础的字符串处理函数。对于grep函数，结果只有匹配或者不匹配，因此匹配时输出向量中该元素的下标，如果是单个字符就输出1，对于grepl，和grep其实一样，不过输出的是逻辑值，匹配就是T，不匹配就是F。参数“value”默认为F，输出的值就是刚才说的元素下标或者逻辑值，如果改成T，就会输出查找的字符串。还有一个参数“ignore.case”，默认是F，表示大小写敏感，可以改为T，表示大小写不敏感。参数“useBytes”默认是F，表示按字符查找，如果是T则表示按字节查找，对于中文字符影响还是很大的。参数“invert ”默认为F，表示正常的查找，如果为T则查找模式的补集。像sub和gsub这样的替换函数，还多一个参数“replacement”，用来表示替换的字符。 这些函数的参数都比较类似，但是输出各不一样，grep输出向量的下标，实际上就是找到与没找到，grepl返回的逻辑值更能说明问题。sub是一个很强大的替换函数，远胜过substr，正则表达式中可以设置非常灵活的规则，然后返回被替换后的字符串，如果正则表达式写得好，基本可以解决所有子字符串的问题。sub函数和gsub函数唯一的差别在于前者匹配第一次符合模式的字符串，后者匹配所有符合模式的字符串，也就是说在替换的时候前者只替换第一次符合的，后者替换所有符合的。regexpr和gregexpr被使用的似乎比较多，因为它们很像其他语言中的instr函数，可以查找到某些字符在字符串中出现的位置，不过我觉得用处并不是很大，因为通常情况下寻找某字符位置的目的就是为了做相关处理，而sub都能搞定。regexpr和gregexpr的关系和sub与gsub差不多，gregexpr操作向量时会返回列表。 以上就是grep系列函数的一些用法，根据例子可以很方便地使用，个人建议使用参数“pattern”和“x”就行（sub和gsub当然还有replacement），其他的都用默认的。在pattern中按照egrep的规则写正则表达式，基本上可以解决所有的字符串处理问题。只需要对正则表达式有简单的了解，就可以得到R中这些强大的功能。关于正则表达式的用法就在后文中分解了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[R中正则表达式简介z]]></title>
      <url>%2Fstylus%2F2012%2F12%2F05%2Fr-reg-exp%2F</url>
      <content type="text"><![CDATA[原文地址：http://jliblog.com/archives/28 R中的grep、grepl、sub、gsub、regexpr、gregexpr等函数都使用正则表达式的规则进行匹配。默认是egrep的规则，也可以选用Perl语言的规则。在这里，我们以R中的sub函数为例（因为该函数可以返回替换字符串后的具体内容）介绍正则表达式的用法。 对该函数的逻辑参数都使用默认值（ignore.case = FALSE，表示大小写敏感；extended = TRUE，表示使用egrep规则；perl = FALSE，表示不使用Perl规则；fixed = FALSE，表示不使用精确匹配；useBytes = FALSE，表示按字符匹配）。另外三个中，pattern为字符串表示正则表达式，replacement也是字符串表示替换的内容，x为字符型向量表示被替换的字符向量。该函数会根据pattern的规则对x中各元素进行搜索，遇到符合条件的第一个子字符串的位置（gsub是替换所有符合条件的），用replacement替换该子字符串，返回替换后的结果，和x的结构相同。为了清晰地介绍例子，我们对replacement统一赋值为“”，相当于去掉搜寻出来的子字符串。例如sub(&quot;a&quot;,&quot;&quot;,c(&quot;abcd&quot;,&quot;dcba&quot;))，将向量中的两个字符串中的a都去掉了，返回[1] &quot;bcd&quot; &quot;dcb&quot;。该例中的&quot;a&quot;只是一个字符，并不是正则表达式，真正的正则表达式依靠元字符进行灵活的匹配。 “^”匹配一个字符串的开始，比如sub(&quot;^a&quot;,&quot;&quot;,c(&quot;abcd&quot;,&quot;dcba&quot;))，表示将开头为a的字符串中的a替换成空，在返回值中可以发现后面出现的a并没有被替换。如果要将开头的一个字符串替换，简单地写成“^ab”就行。 “$”匹配一个字符串的结尾，比如sub(&quot;a$&quot;,&quot;&quot;,c(&quot;abcd&quot;,&quot;dcba&quot;))表示将以a结尾的字符串中的a替换成空。&quot;.&quot;表示除了换行符以外的任一字符，比如sub(&quot;a.c&quot;,&quot;&quot;,c(&quot;abcd&quot;,&quot;sdacd&quot;))。“*”表示将其前的字符进行0个或多个的匹配，比如sub(&quot;a*b&quot;,&quot;&quot;,c(&quot;aabcd&quot;,&quot;dcaaaba&quot;))。类似地，“?”匹配0或1个正好在它之前的那个字符，“+”匹配1或多个正好在它之前的那个字符。“.*”可以匹配任意字符，比如sub(&quot;a.*e&quot;,&quot;&quot;,c(&quot;abcde&quot;,&quot;edcba&quot;))。 “|”表示逻辑的或，比如sub(&quot;ab|ba&quot;,&quot;&quot;,c(&quot;abcd&quot;,&quot;dcba&quot;))，可以替换ab或者ba。“^”还可以表示逻辑的补集，需要写在“[]”中，比如sub(&quot;[^ab]&quot;,&quot;&quot;,c(&quot;abcd&quot;,&quot;dcba&quot;))，由于sub只替换搜寻到的第一个，因此这个例子中用gsub效果更好。 “[]”还可以用来匹配多个字符，如果不使用任何分隔符号，则搜寻这个集合，比如在sub(&quot;[ab]&quot;,&quot;&quot;,c(&quot;abcd&quot;,&quot;dcba&quot;))中，和&quot;a|b&quot;效果一样。“[-]”的形式可以匹配一个范围，比如sub(&quot;[a-c]&quot;,&quot;&quot;,c(&quot;abcde&quot;,&quot;edcba&quot;))匹配从a到c的字符，sub(&quot;[1-9]&quot;,&quot;&quot;,c(&quot;ab001&quot;,&quot;001ab&quot;))匹配从1到9的数字。 以上是最基础的正则表达式元字符，在一些正则表达式的书籍和资料中有非常详细的介绍。最后需要提一下的是“贪婪”和“懒惰”的匹配规则。默认情况下是匹配尽可能多的字符，是为贪婪匹配，比如sub(&quot;a.*b&quot;,&quot;&quot;,c(&quot;aabab&quot;,&quot;eabbe&quot;))，默认匹配最长的a开头b结尾的字串，也就是整个字符串。如果要进行懒惰匹配，也就是匹配最短的字串，只需要在后面加个“?”，比如sub(&quot;a.*?b&quot;,&quot;&quot;,c(&quot;aabab&quot;,&quot;eabbe&quot;))，就会匹配最开始找到的最短的a开头b结尾的字串。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[R的内存管理和垃圾清理z]]></title>
      <url>%2Fstylus%2F2012%2F12%2F05%2Fr-mem-gc%2F</url>
      <content type="text"><![CDATA[原文地址：http://jliblog.com/archives/276 写R程序的人，相信都会遇到过“cannot allocate vector of size”或者“无法分配大小为…的矢量”这样的错误。原因很简单，基本都是产生一个大矩阵等对象时发生的，最干脆的解决办法有两种，第一种是加大内存换64位系统，第二种是改变算法避免如此大的对象。第一种办法，是最好的办法，不过大对象的需求是没有止尽的，终究不是长久之道。第二种办法是最好的思路，无论多么大的对象都是可以弄小的，无非就是分而治之、时间换空间等，对算法的研究也是没有止尽的。 升级硬件和改进算法是解决内存问题的永恒的办法，超出了本文想要表述的范围。在这里，只是简单谈谈R语言的内存管理和垃圾清理机制，只有对这些有所了解，才能对任何问题都能找到针对性的解决办法。 相信所有人在遇到无法分配矢量这一问题后，都能很快地找到改变“–max-mem-size”（假设都是在Windows下）或者“memory.limit”的方法，的确，这是最直接的方法。因为出现新对象无法分配内存的直接原因就是内存不够，R获取内存的方式和其他应用程序一样，都是向操作系统要内存，如果无法获取连续的某个大小的内存空间，就会出现无法分配内存的错误。由于大家使用R时通常都是自动安装自动运行，操作系统愿意分配给R多少内存都是采用的默认设置，在R中使用命令memory.size(NA)或者memory.limit()可以看到当前设置下操作系统能分配给R的最大内存是多少。同时可以使用memory.size(F)查看当前R已使用的内存，memory.size(T)查看已分配的内存（注意刚开始时已使用内存和已分配内存是同步增加的，但是随着R中的垃圾被清理，已使用内存会减少，而已分配给R的内存一般不会改变。）。如果memory.limit()得到的数是一个很小的内存，说明操作系统太小气了，留那么多内存给别的程序用不给R。解决办法很简单，就是打开R时不通过双击图标，而是在“运行”中输入“Rgui –max-mem-size 2Gb”（假设要分配2G内存且在环境变量中正确设置了R的安装文件夹），在运行memory.limit()就会发现内存加大了，其实更简单的方法是直接在R中运行memory.limit(2000)，效果一模一样，而且不用重启R。 可惜大多数情况下改变这个值也不会有效果，因为这个值已经足够大，那么无法分配内存的原因不是操作系统小气对R不公，而是它确实拿不出来，谁找它要也拿不出来。这个时候就需要了解R的内存管理到底是怎么回事了。 R的操作基本都是通过变量来实现的，变量可以是各种各样的对象类型，R中的对象（比如矩阵）在内存中存于两种不同的地方，一种是堆内存（heap），其基本单元是“Vcells”，每个大小为8字节，新来一个对象就会申请一块空间，把值全部存在这里，和C里面的堆内存很像。第二种是地址对（cons cells），和LISP里的cons cells道理一样，主要用来存储地址信息，最小单元一般在32位系统中是28字节、64位系统中是56字节。在R中，可以通过ls()来查看当前所有对象名，对于每一个对象，可以通过object.size(x)来查看其占用内存的大小。 如果是因为当前对象占用内存过多，那么可以通过处理对象来获取更大的可用内存。一个很有用的方法是改变对象的存储模式，通过storage.mode(x)可以看到某个对象的存储模式，比如某个矩阵默认就是“double”的，如果这个矩阵的数值都是整数甚至0-1，完全没必要使用double来占用空间，可以使用storage.mode(x） &lt;- &quot;integer&quot;将其改为整数型，可以看到该对象的大小会变为原来的一半。 对于当前对象占用内存过多的情况，一个很主要的原因就是在写程序的过程中造成了太多的中间对象，R是一个很方便的语言，大家使用它一般都是写各种复杂的模型和算法，很多问题构造几个矩阵经过一系列的矩阵运算就可以很快解决，但是这些辅助算法的大矩阵如果不清理，就会留在系统中占内存。因此在写程序中对于中间对象，经常使用rm(x)是一个很好的习惯，如果是非常重要的信息不想删掉，可以存在硬盘里，比如csv文件或者RSqlite等。 rm()用来删除对象时，只会删除变量的引用，并不会立即清除占用的内存空间，失去引用的对象就成了内存中的垃圾，R清理垃圾的机制和JAVA很像，都是在一定时间内自动发现垃圾再集中清理。所以通过rm()删除对象后在Windows的任务管理器可以看到R进程占用的内存并没有被立即释放，而是过一段时间后才会清理。如果想要删除的对象立刻被清理，可以运行垃圾处理函数gc()，将会立刻释放空间。但是通常不是很必要，因为当内存不够时系统会自动清理垃圾的，我们要做的只是将不再使用的对象rm()掉，在写R程序时应该养成习惯。 很多时候，在程序中尤其是循环里，如果内存处理不当，还没来得及垃圾清理，就会把内存撑爆，因此新建对象时一定要考虑到R的内存管理机制。大家都知道R中矩阵的维度并不需要赋一个固定的值（很多语言的数组长度不能为变量），这为写程序带来了极大的方便，因此经常在循环中会出现某个矩阵越来越长的情况，实际上，矩阵每增长一次，即使赋给同名的变量，都需要新开辟一块更大的空间，假设初始矩阵为100K，第二个为101K，一直增到120K，那么，将会分别开辟100K、101K一直到120K的连续堆内存，如果一开始就开一块120K的，使之从101K逐渐增长到120K，将会大大地节约内存。cbind函数也是这个道理，所以在循环中要注意不要滥用。 要处理好内存的问题其实很简单，养成随时关注内存的习惯即可，每新建一个对象或者循环赋值的时候适当估算一下所占内存，大内存的中间变量用完后记得清理。如果实在需要新建一个巨大的对象，那么就该考虑一些专门处理大内存对象以及并行处理的包，比如bigmemory等。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[R中如何取消科学计数法z]]></title>
      <url>%2Fstylus%2F2012%2F12%2F04%2Fcancel-scientific-notation-in-r%2F</url>
      <content type="text"><![CDATA[原文地址：http://bbs.pinggu.org/thread-1403060-1-1.html R应该会自动的把太大和太小的数用科学计数法来表示，一般的数应该就是直接表示吧。 12345&gt; 10^seq(1:5)[1] 1e+01 1e+02 1e+03 1e+04 1e+05&gt; options(scipen=200)&gt; 10^seq(1:5)[1] 10 100 1000 10000 100000]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Matlab统计学工具箱]]></title>
      <url>%2Fstylus%2F2012%2F12%2F04%2Fmatlab-statistics-toolbox%2F</url>
      <content type="text"><![CDATA[表1 概率密度函数 函数名 对应分布的概率密度函数 betapdf 贝塔分布的概率密度函数 binopdf 二项分布的概率密度函数 chi2pdf 卡方分布的概率密度函数 exppdf 指数分布的概率密度函数 fpdf f分布的概率密度函数 gampdf 伽玛分布的概率密度函数 geopdf 几何分布的概率密度函数 hygepdf 超几何分布的概率密度函数 normpdf 正态（高斯）分布的概率密度函数 lognpdf 对数正态分布的概率密度函数 nbinpdf 负二项分布的概率密度函数 ncfpdf 非中心f分布的概率密度函数 nctpdf 非中心t分布的概率密度函数 ncx2pdf 非中心卡方分布的概率密度函数 poisspdf 泊松分布的概率密度函数 raylpdf 雷利分布的概率密度函数 tpdf 学生氏t分布的概率密度函数 unidpdf 离散均匀分布的概率密度函数 unifpdf 连续均匀分布的概率密度函数 weibpdf 威布尔分布的概率密度函数 表2 累加分布函数 函数名 对应分布的累加函数 betacdf 贝塔分布的累加函数 binocdf 二项分布的累加函数 chi2cdf 卡方分布的累加函数 expcdf 指数分布的累加函数 fcdf f分布的累加函数 gamcdf 伽玛分布的累加函数 geocdf 几何分布的累加函数 hygecdf 超几何分布的累加函数 logncdf 对数正态分布的累加函数 nbincdf 负二项分布的累加函数 ncfcdf 非中心f分布的累加函数 nctcdf 非中心t分布的累加函数 ncx2cdf 非中心卡方分布的累加函数 normcdf 正态（高斯）分布的累加函数 poisscdf 泊松分布的累加函数 raylcdf 雷利分布的累加函数 tcdf 学生氏t分布的累加函数 unidcdf 离散均匀分布的累加函数 unifcdf 连续均匀分布的累加函数 weibcdf 威布尔分布的累加函数 表3 累加分布函数的逆函数 函数名 对应分布的累加分布函数逆函数 betainv 贝塔分布的累加分布函数逆函数 binoinv 二项分布的累加分布函数逆函数 chi2inv 卡方分布的累加分布函数逆函数 expinv 指数分布的累加分布函数逆函数 finv f分布的累加分布函数逆函数 gaminv 伽玛分布的累加分布函数逆函数 geoinv 几何分布的累加分布函数逆函数 hygeinv 超几何分布的累加分布函数逆函数 logninv 对数正态分布的累加分布函数逆函数 nbininv 负二项分布的累加分布函数逆函数 ncfinv 非中心f分布的累加分布函数逆函数 nctinv 非中心t分布的累加分布函数逆函数 ncx2inv 非中心卡方分布的累加分布函数逆函数 icdf norminv 正态（高斯）分布的累加分布函数逆函数 poissinv 泊松分布的累加分布函数逆函数 raylinv 雷利分布的累加分布函数逆函数 tinv 学生氏t分布的累加分布函数逆函数 unidinv 离散均匀分布的累加分布函数逆函数 unifinv 连续均匀分布的累加分布函数逆函数 weibinv 威布尔分布的累加分布函数逆函数 表4 随机数生成器函数 函数名 对应分布的随机数生成器 betarnd 贝塔分布的随机数生成器 binornd 二项分布的随机数生成器 chi2rnd 卡方分布的随机数生成器 exprnd 指数分布的随机数生成器 frnd f分布的随机数生成器 gamrnd 伽玛分布的随机数生成器 geornd 几何分布的随机数生成器 hygernd 超几何分布的随机数生成器 lognrnd 对数正态分布的随机数生成器 nbinrnd 负二项分布的随机数生成器 ncfrnd 非中心f分布的随机数生成器 nctrnd 非中心t分布的随机数生成器 ncx2rnd 非中心卡方分布的随机数生成器 normrnd 正态（高斯）分布的随机数生成器 poissrnd 泊松分布的随机数生成器 raylrnd 瑞利分布的随机数生成器 trnd 学生氏t分布的随机数生成器 unidrnd 离散均匀分布的随机数生成器 unifrnd 连续均匀分布的随机数生成器 weibrnd 威布尔分布的随机数生成器 表5 分布函数的统计量函数 函数名 对应分布的统计量 betastat 贝塔分布函数的统计量 binostat 二项分布函数的统计量 chi2stat 卡方分布函数的统计量 expstat 指数分布函数的统计量 fstat f分布函数的统计量 gamstat 伽玛分布函数的统计量 geostat 几何分布函数的统计量 hygestat 超几何分布函数的统计量 lognstat 对数正态分布函数的统计量 nbinstat 负二项分布函数的统计量 ncfstat 非中心f分布函数的统计量 nctstat 非中心t分布函数的统计量 ncx2stat 非中心卡方分布函数的统计量 normstat 正态（高斯）分布函数的统计量 poisstat 泊松分布函数的统计量 raylstat 瑞利分布函数的统计量 tstat 学生氏t分布函数的统计量 unidstat 离散均匀分布函数的统计量 unifstat 连续均匀分布函数的统计量 weibstat 威布尔分布函数的统计量 表6 参数估计函数 函数名 对应分布的参数估计 betafit 贝塔分布的参数估计 betalike 贝塔对数似然函数的参数估计 binofit 二项分布的参数估计 expfit 指数分布的参数估计 gamfit 伽玛分布的参数估计 gamlike 伽玛似然函数的参数估计 mle 极大似然估计的参数估计 normlike 正态对数似然函数的参数估计 normfit 正态分布的参数估计 poissfit 泊松分布的参数估计 unifit 均匀分布的参数估计 weibfit 威布尔分布的参数估计 weiblike 威布尔对数似然函数的参数估计 表7 统计量描述函数 函数名 描述 bootstrap 任何函数的自助统计量 corrcoef 相关系数 cov 协方差 crosstab 列联表 geomean 几何均值 grpstats 分组统计量 harmmean 调和均值 iqr 内四分极值 kurtosis 峰度 mad 中值绝对差 mean 均值 median 中值 moment 样本模量 nanmax 包含缺失值的样本的最大值 Nanmean 包含缺失值的样本的均值 nanmedian 包含缺失值的样本的中值 nanmin 包含缺失值的样本的最小值 nanstd 包含缺失值的样本的标准差 nansum 包含缺失值的样本的和 prctile 百分位数 range 极值 skewness 偏度 std 标准差 tabulate 频数表 trimmean 截尾均值 var 方差 表8 统计图形函数 函数名 描述 boxplot 箱形图 cdfplot 指数累加分布函数图 errorbar 误差条图 fsurfht 函数的交互等值线图 gline 画线 gname 交互标注图中的点 gplotmatrix 散点图矩阵 gscatter 由第三个变量分组的两个变量的散点图 lsline 在散点图中添加最小二乘拟合线 normplot 正态概率图 pareto 帕累托图 qqplot Q-Q图 rcoplot 残差个案次序图 refcurve 参考多项式曲线 refline 参考线 surfht 数据网格的交互等值线图 weibplot 威布尔图 表9 统计过程控制函数 函数名 描述 capable 性能指标 capaplot 性能图 ewmaplot 指数加权移动平均图 histfit 添加正态曲线的直方图 normspec 在指定的区间上绘正态密度 schart S图 xbarplot x条图 表10 聚类分析函数 函数名 描述 cluster 根据linkage函数的输出创建聚类 clusterdata 根据给定数据创建聚类 cophenet Cophenet相关系数 dendrogram 创建冰柱图 inconsistent 聚类树的不连续值 linkage 系统聚类信息 pdist 观测量之间的配对距离 squareform 距离平方矩阵 zscore Z分数 表11 线性模型函数 函数名 描述 anova1 单因子方差分析 anova2 双因子方差分析 anovan 多因子方差分析 aoctool 协方差分析交互工具 dummyvar 拟变量编码 friedman Friedman检验 glmfit 一般线性模型拟合 kruskalwallis Kruskalwallis检验 leverage 中心化杠杆值 lscov 已知协方差矩阵的最小二乘估计 manova1 单因素多元方差分析 manovacluster 多元聚类并用冰柱图表示 multcompare 多元比较 多项式评价及误差区间估计 polyfit 最小二乘多项式拟合 polyval 多项式函数的预测值 polyconf 残差个案次序图 regress 多元线性回归 regstats 回归统计量诊断 Ridge 岭回归 rstool 多佳节又重阳维响应面可视化 robustfit 稳健回归模型拟合 stepwise 逐步回归 x2fx 用于设计矩阵的因子设置矩阵 表12 非线性回归函数 函数名 描述 nlinfit 非线性最小二乘数据拟合（牛顿法） nlintool 非线性模型拟合的交互式图形工具 nlparci 参数的置信区间 nlpredci 预测值的置信区间 nnls 非负最小二乘 表13 试验设计函数 函数名 描述 cordexch D-优化设计（列交换算法） daugment 递增D-优化设计 dcovary 固定协方差的D-优化设计 ff2n 二水平完全析因设计 fracfact 二水平部分析因设计 fullfact 混合水平的完全析因设计 hadamard Hadamard矩阵（正交数组） rowexch D-优化设计（行交换算法） 表14 主成分分析函数 函数名 描述 barttest Barttest检验 pcacov 源于协方差矩阵的主成分 pcares 源于主成分的方差 princomp 根据原始数据进行主成分分析 表15 多元统计函数 函数名 描述 classify 聚类分析 mahal 马氏距离 manova1 单因素多元方差分析 manovacluster 多元聚类分析 表16 假设检验函数 函数名 描述 ranksum 秩和检验 signrank 符号秩检验 signtest 符号检验 ttest 单样本t检验 ttest2 双样本t检验 ztest z检验 表17 分布检验函数 函数名 描述 jbtest 正态性的Jarque-Bera检验 kstest 单样本Kolmogorov-Smirnov检验 kstest2 双样本Kolmogorov-Smirnov检验 lillietest 正态性的Lilliefors检验 表18 非参数函数 函数名 描述 friedman Friedman检验 kruskalwallis Kruskalwallis检验 ranksum 秩和检验 signrank 符号秩检验 signtest 符号检验 表19 文件输入输出函数 函数名 描述 caseread 读取个案名 casewrite 写个案名到文件 tblread 以表格形式读数据 tblwrite 以表格形式写数据到文件 tdfread 从表格间隔形式的文件中读取文本或数值数据 表20 演示函数 函数名 描述 aoctool 协方差分析的交互式图形工具 disttool 探察概率分布函数的GUI工具 glmdemo 一般线性模型演示 randtool 随机数生成工具 polytool 多项式拟合工具 rsmdemo 响应拟合工具 robustdemo 稳健回归拟合工具]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Matlab画二维图心得]]></title>
      <url>%2Fstylus%2F2012%2F11%2F23%2Fmatlab-ezplot-latex%2F</url>
      <content type="text"><![CDATA[plot()函数主要用于已有坐标对的连接（包括单个坐标，利用这一点再加上修改MarkSize可以画出指定大小的圆点等各种符号）； ezplot()既可以画普通函数的图像，也可以画隐函数图像，换句话说，对于给定的函数，ezplot()可以实现plot()的结果； 根据ezplot()作隐函数图像的原理，http://www.ilovematlab.cn/thread-21438-1-1.html给出了一种用ezplot()同时画两条曲线的巧妙方法，但要注意该方法无法将两条曲线区分开来，因此可能会导致利用legend()添加图例的意图无法达到。 添加多条曲线时要利用好hold on这一语句； axis的刻度在默认情况下会自动根据给出的最后一次ezplot()进行调整，如果不希望画出的图像为自适应大小，需要在图像绘制完成后，手工指定axis的x轴与y轴最大、最小刻度； 添加箭头可以用annotation完成，要注意其坐标是相对大小，在[0,1]之间，我个人比较喜欢PSTricks的箭头风格，因此也会考虑在PSTricks中对已生成的图像进行深加工； 可以将ezplot()和legend()的结果赋给某个变量，再通过set()函数对图像对象或者legend对象进行字体大小、颜色等的操作； latex()函数可以用于将指定的符号表达式转换成LaTeX语法格式； sym()函数可以用于将某个数值对象转换成符号表达式以供latex()函数使用； title、xlabel、ylabel、zlabel、textbox和text等函数可以利用&#39;Interpreter&#39;,&#39;latex&#39;加载LaTeX格式； 因为Legend没有Interpreter属性，所以如果要在其中使用LaTeX，必须获取对应的文字句柄，并对文字对象设置String和Interpreter属性，关于这一点可以参考：http://www.mathworks.com/matlabcentral/newsreader/view_thread/254118和http://sites.google.com/site/sleepingwalking/matlab/latex-in-legend，从下面的示例可以看到，String不一定必要； 将图像插入LaTeX文档时，建议不要使用pdf格式，而是使用eps格式，否则得到的图像结果锯齿感会比较明显。 在Matlab中使用latex()函数的效果12345678&gt;&gt; x = [1:5;6:10;11:15];&gt;&gt; y = sym(x);&gt;&gt; latex(y) ans =\left(\begin&#123;array&#125;&#123;ccccc&#125; 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5\\ 6 &amp; 7 &amp; 8 &amp; 9 &amp; 10\\ 11 &amp; 12 &amp; 13 &amp; 14 &amp; 15 \end&#123;array&#125;\right)&gt;&gt; syms a b;&gt;&gt; x = sin(a) + b/a;&gt;&gt; latex(x) ans =\sin\!\left(a\right) + \frac&#123;b&#125;&#123;a&#125; 下面的例程中用到了大部分上面的心得1234567891011121314151617181920212223% 使用 ezplot 画多条曲线，不需要加 legend 时，可以考虑 f1*f2 型% 实际上这是一种对 ezplot 隐函数原理画线的深刻理解syms x y;a = sin(x) + sinh(y);b = sin(x);f_a = ezplot(a);hold onf_b = ezplot(b);set(f_a, 'LineWidth', 3);xx = legend('$$\alpha^a_b (x)\frac&#123;b&#125;&#123;a&#125;$$','\alpha');% 前一个为 LaTeX 格式，后一个为 LaTeX 语法；set(xx,'Interpreter','latex')% legend 中的 latex 解释器直接使用不起作用；text() 函数等可以直接用。% legend 可以作为一个对象赋给某个变量以进一步修改设置xlabel('$$\sin x$$','interpreter','latex')title('');text('Interpreter','latex',... 'String','$$\int_0^x\!\int_y dF(u,v)$$',... 'Position',[.5 .5],... 'FontSize',16)% latex(s) 转化符号表达式为 LaTeX 形式% title、xlabel、ylabel、zlabel、textbox和legend、text 可以利用 'Interpreter','latex' 加载 LaTeX 格式% sym() 函数可以将一个数值矩阵转换成为一个可以被 latex() 处理的符号类结果 一个利用PSTricks修改已有图像的简单例子12345678910111213141516% !Mode:: "TeX:UTF-8"\documentclass&#123;ctexart&#125;\usepackage&#123;amsmath,bm,galois&#125;\usepackage&#123;pstricks&#125;\begin&#123;document&#125;\pagestyle&#123;empty&#125;\begin&#123;pspicture&#125;(-1,-1)(5,5)\rput[bl](0,0)&#123;\includegraphics&#123;fig1&#125;&#125;%\psgrid[subgriddiv=0]\rput(0,0)&#123;价值&#125;\rput(3.15,0)&#123;结果&#125;\rput(1.6,2.85)&#123;报价&#125;\rput(0.4,1.5)&#123;$\bm&#123;\beta&#125;$&#125;\rput(3.5,1.5)&#123;$(\bm&#123;\pi&#125;,\bm&#123;\mu&#125;)$&#125;\rput(1.5,-0.32)&#123;$(\bm&#123;\pi&#125;,\bm&#123;\mu&#125;)\comp\bm&#123;\beta&#125;$&#125;\end&#123;pspicture&#125;\end&#123;document&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[apsrtable在knitr中生成LaTeX表格]]></title>
      <url>%2Fstylus%2F2012%2F11%2F21%2Fapsrtable-knitr-latex-table%2F</url>
      <content type="text"><![CDATA[原文地址：http://cos.name/cn/topic/108631 apsrtable()里有个Sweave参数，若设为TRUE，则生成tabular环境，若为默认的FALSE，则为table环境。 12345678\begin&#123;table&#125;[htbp]\caption&#123;some text&#125;\label&#123;tb:ex&#125;\centering&lt;&lt;results='asis'&gt;&gt;=apsrtable(mod1, mod2, mod3, Sweave = TRUE)@\end&#123;table&#125; Yihui: 这大概就是最好的办法了吧……这参数名干嘛非得叫Sweave，明明意思是tabular.only。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[knitr、Markdown、Pandoc相关的几份资料]]></title>
      <url>%2Fstylus%2F2012%2F09%2F17%2Fknitr%2F</url>
      <content type="text"><![CDATA[为什么Markdown+R有较大概率成为科技写作主流？http://www.yangzhiping.com/tech/r-markdown-knitr.html Markdown语法说明：http://wowubuntu.com/markdown/ Markdown Wiki：http://en.wikipedia.org/wiki/Markdown Pandoc：http://johnmacfarlane.net/pandoc/ 如何高效利用GitHub：http://www.yangzhiping.com/tech/github.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Office卸载工具下载]]></title>
      <url>%2Fstylus%2F2012%2F02%2F07%2Foffice-uninstall-tools%2F</url>
      <content type="text"><![CDATA[Office 2003 卸载工具下载 Office 2007 卸载工具下载 Office 2010 卸载工具下载 参考：http://support.microsoft.com/kb/290301]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[引用最近的一个公式：lasteqn z]]></title>
      <url>%2Fstylus%2F2011%2F12%2F28%2Flasteqn%2F</url>
      <content type="text"><![CDATA[原文地址：http://bbs.ctex.org/viewthread.php?tid=69755 1234567891011121314151617181920212223242526272829303132333435\documentclass&#123;article&#125;\usepackage&#123;amsmath&#125;\providecommand\currentseclabel&#123;&#125;\newcommand\seclabel[1]&#123; \renewcommand\currentseclabel&#123;#1&#125;% \label&#123;sec:#1&#125;&#125;\newcommand\secref[1]&#123; \ref&#123;sec:#1&#125;&#125;\newcommand\eqlabel[1]&#123; \label&#123;eq:\currentseclabel:#1&#125;&#125;\let\saveeqref\eqref\renewcommand\eqref[2][\currentseclabel]&#123; \saveeqref&#123;eq:#1:#2&#125;&#125;\newcommand\lasteqn&#123;(\theequation)&#125;\begin&#123;document&#125;\section&#123;Rectangle&#125;\seclabel&#123;rect&#125;\begin&#123;equation&#125;\eqlabel&#123;area&#125;A = ab\end&#123;equation&#125;Area formula \eqref&#123;area&#125;.Previous equation \lasteqn.\section&#123;Circle&#125;\seclabel&#123;circ&#125;\begin&#123;equation&#125;\eqlabel&#123;area&#125;A = \pi r^2\end&#123;equation&#125;Area formula \eqref&#123;area&#125;.\section&#123;Summary&#125;Area of rectangles see \eqref[rect]&#123;area&#125; in section~\secref&#123;rect&#125;;area of circles see \eqref[circ]&#123;area&#125; in section~\secref&#123;circ&#125;.\end&#123;document&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[底层命令解释]]></title>
      <url>%2Fstylus%2F2011%2F12%2F02%2Flatex-basic-instructions%2F</url>
      <content type="text"><![CDATA[判断某个命令是否已经用过 判断是否已经定义用\ifdefined或者\ifcsname，如果没有eTeX支持也可以用\ifx\foo\undefined或者 LaTeX 内核的\@ifundefined。 判断是否用过一遍，可以在\foo的定义中设置一个全局变量，然后在后面检测。 \let和\xdef有什么区别？ \xdef把定义中的内容完全展开，用来定义一个宏；\let让新宏与旧宏意义相同。\xdef就是\global\edef。\let没有\global的意思。 1234\def\a&#123;foo&#125;\def\b&#123;\a&#125;\edef\c&#123;\b&#125; 得到的是 \c -&gt; foo\let\d\b 得到的是 \d -&gt; \a 一个外链：What is the difference between \let and \edef \renewcommand*的作用 \renewcommand所带参数可以包含用\par或空行表示的新段落；\renewcommand*不行 \string的作用 将一个命令输出为带斜杠的字符串。 \expandafter的作用 让制控命令顺序颠倒过来，后面的命令先起作用，下边是一个证明的例子： 12345\def\test&#123;9999&#125;\makeatletter\def\testt#1#2#3#4&#123;\@alph&#123;#1&#125;\@Alph&#123;#2&#125;\@Roman&#123;#3&#125;\@roman&#123;#4&#125;&#125;\makeatother\expandafter\testt\test 如果不加\expandafter的话： 1\testt\test 就会出错。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CTeX 2.9.0.152下Beamer中使用theorem环境出错的解决方法z]]></title>
      <url>%2Fstylus%2F2011%2F11%2F27%2Fctex-2-9-0-152-beamer-theorem%2F</url>
      <content type="text"><![CDATA[原文地址：http://hi.baidu.com/zjunmm/blog/item/0915d010d7ce2d175aaf53d1.html CTeX 2.9.0.152 下在 Beamer 中使用 theorem, definitioin 环境会出错： ! Undefined control sequence. \trans@languagepath -&gt;\languagename ,English l.226 \end{frame} 解决方法有两种： 在导言区添加 \usepackage[english]{babel}; 在线升级到最新版本。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[footmisc宏包选项的简短说明]]></title>
      <url>%2Fstylus%2F2011%2F11%2F21%2Foptions-of-footmisc%2F</url>
      <content type="text"><![CDATA[原文地址：http://hi.baidu.com/albertleemon/blog/item/a7f4d2e715772926b93820a3.html 该宏包提供了许多选项，可使脚注命令\footnote{注释}生成多种样式的脚注。其中： perpage：为每页脚注单独编号； stable：可避免章节标题中的脚注随同章节标题出现在目录或页眉之中； side：将脚注改为边注； multiple：给正文中两个以上的并排脚注标号之间加上分隔逗号； para：将本页的所有脚注合为一个段落； symbol：将脚注的数字序号改为*号等不同的符号； ragged：不采用断词等方法使脚注文本右端对齐； marginal：使脚注首行不缩格； flushmargin：类似marginal选项，只是脚注序号更靠近脚注； hang：使脚注文本向右缩进一段距离； norule：取消正文与脚注之间的一条短横线。 PS：在使用 footmisc 宏包后，如果脚注的编号不对或者编号所在的位置有问题时，再编译一次即可解决。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[用 pgfpages 生成 slides 的 4 in 1 版式效果]]></title>
      <url>%2Fstylus%2F2011%2F11%2F12%2Fpgfpages-slides-4-in-1-changing-margins%2F</url>
      <content type="text"><![CDATA[Getting a 4 in 1 pdf Slides document and “Changing PDF Margins With The pdfpages Package” 123456789\documentclass[a4paper, landscape]&#123;article&#125;\usepackage[final]&#123;pdfpages&#125;\begin&#123;document&#125;\includepdf[nup=2x2,pages=-, delta=15 15, offset=20 0, frame, scale=0.92,% turn=false]&#123;slides.pdf&#125;\end&#123;document&#125;% offset=20 0 为偏移横向的内容，给左边留一定的空白用于装订；% 不使用 offset 的纵向偏移，否则虽然下方有空白，但天头没有；% 解决纵向留空使用了 scale 选项，直接缩小页面的尺寸，产生自动纵向留白。 用 Beamer 做的 Slides，最刚开始用 Acrobat 打印机生成幻灯片的四合一效果，但发现 Acrobat 打印过程中会对图片的质量造成一定的损伤。 后来发现psnup工具可以实现4 in 1的效果，但试验之后感觉速度和方便程度都很欠缺，需要先将 pdf 文件转换 ps 文件，光是这个过程就太漫长，受不了；另外就是该工具提供的选项看起来不是很舒服。 最后回想起其实 LaTeX 自带的pgfpages宏包可以完成这个任务，又回头查了了下 Beam User Guide，发现 Beamer 中也尝试过使用该宏包。但是 Beamer 中的\pgfpagesuselayout{2 on 1}[a4paper,border shrink=5mm]类命令我不能直接在 Beamer 之外用，而pgfpages中的delta与offset组合工作还存在问题(见上面的代码注释)，最后发现\includepdf的scale选项配合delta与offset就可以完美的达到想要的效果，问题搞定！ PS：事实上pgfpages宏包的手册中没有对scale选项进行专门的说明，这个选项其实源于graphicsx宏包的\includegraphic命令，解决上面问题的思路来自下面的资料： http://magic.aladdin.cs.cmu.edu/2007/11/13/changing-pdf-margins-with-the-pdfpages-package/ http://www.tardis.ed.ac.uk/~ajcd/psutils/psnup.html http://apps.hi.baidu.com/share/detail/21414399]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何在Word中分栏状态下正确的输入脚注？]]></title>
      <url>%2Fstylus%2F2011%2F11%2F10%2Fword-footnote%2F</url>
      <content type="text"><![CDATA[在论文排版中，在题目或作者处插入了脚注后，再对正文分栏时；或者先分栏，再在题目或作者处插入脚注，分栏后的正文就跑到下一页上去了。 稿件格式的要求示意图如下： 解决方案： word 2003：“工具”→“选项”→“兼容性”→“选项”→“按照word 6.x/95/97的方式排放脚注”； word 2007：“左上角圆形图标”→“word选项”→“在左边列中点高级”→在右边的“兼容性选项”下点“版式选项”，展开版式选项，勾选按“word 6.x/95/97的方式排安排脚注”。 经过以上操作后，分栏后，加入脚注或者加入脚注后再分栏，正文跑到第二页的问题就可以解决了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[LaTeX问题贴收集]]></title>
      <url>%2Fstylus%2F2011%2F11%2F07%2Flatex-solution%2F</url>
      <content type="text"><![CDATA[各类问题 TeX Live 2011 中的 ConTeXt MkIV 配置(包括 Linux 和 Win7) 中文书籍模板示例 (《线性代数》的文档类) What does \ifx\#1\ stand for? How to include a picture over two pages, left part on left side, right on right (for books)? How to change title in listings? 代码环境跨页问题(一个比较完善的 Listings 设置示例) 用listings包实现左边代码右边输出 高中数学试卷举例 多种期刊的统一模板 我的beamer幻灯片模板 多子图分页 学习底层命令的参考书目 如何实现重复 抛砖引玉谈“脆弱” LaTeX的循环里面怎样定义命令 这种改中文标点 catcode 的方法靠谱么 生成可展开的改变大小写命令 重要模块 Asymptote 中文资源导引 PGF/TikZ 学习帖汇总]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用Windows优化大师导致Win7出现的两个问题]]></title>
      <url>%2Fstylus%2F2011%2F02%2F26%2Fwindows-opti-master%2F</url>
      <content type="text"><![CDATA[“其他用户”该问题是在使用Windows优化大师进行注册表清理的时候导致的问题。目前官方没有给出相应的解决方法。该问题的描述见如下地址：http://social.answers.microsoft.com/Forums/en-US/w7security/thread/63cea659-f6a0-412d-a0b1-952a26c1df44；该问题的解决方法见如下地址：http://jonhoo.wordpress.com/2010/06/24/windows-7-login-screen-only-showing-last-logged-on-user-and-other-user/。请在按操作进行这前根据解决方案的步骤备份好注册表。 Ever since my initial install of Windows 7, there has been one thing nagging me. The Windows welcome screen only ever displayed the avatar for the last logged on user and a blank image with the label “Other users”. When the latter was clicked, two text fields would appear prompting for username and password.I have tried numerous solutions, but none have worked until very recently when a user with the nickname “SaySay” came up with the following solution: Legal disclaimer: Modifying REGISTRY settings incorrectly can cause serious problems that may prevent your computer from booting properly. Neither I nor Microsoft can guarantee that any problems resulting from the configuring of REGISTRY settings can be solved. Modifications of these settings are at your own risk Open regedit： Press Windows+R Type regedit + enter Navigate to [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList] You will probably want to right-click on “ProfileList” and click export to save the entire subtree in case something goes wrong. You will find several subfolders or “keys” named something like “S-1-x-xx…”, open them one at the time Each should contain at least the three value-sets, “Flags”, “ProfileImagePath” and “State”, some will contain more Look at the end of ProfileImagePath for the name of the user represented by the key You will usually have one for each user on the system, and one for each of the three system entries ‘systemprofile’, ‘LocalService’ and ’NetworkService’ Delete any key (i.e. the whole “S-1-x-xx” folder) that does not contain at least those three values The welcome screen should now work as expected, showing the avatar for all registered users; enjoy! “Computer Management Snapin Launcher 已停止工作”这个是在安装了最新版的Windows优化大师后产生的问题。Uninstall该软件之后问题就解决。 说明：现在的Windows优化大师已经不如从前，可以选择的优化软件也比较多。个人不推荐随意用各种软件来修改系统的设置。其实不经济进行软件的各种安装与反安装的话，系统也不怎么需要进行优化。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[listings排源代码，如何让反斜杠高亮显示？z]]></title>
      <url>%2Fstylus%2F2011%2F01%2F03%2Flsset-highlight-blackslash%2F</url>
      <content type="text"><![CDATA[原文地址：http://bbs.chinatex.org/forum.php?mod=viewthread&amp;tid=7282&amp;extra=page%3D1 原始出处：http://tex.stackexchange.com/questions/17774/listings-package-can-i-include-a-backslash-in-language-keyword-begin-for 如第一幅图所示，高亮的结果是有问题的，也不太好看，实际，我们需要用texcsstyle来设置即可，有关该指令的作用参考listings宏包的手册或http://www.chinatex.org/archives/620，这里的cs即控制序列。 123456789101112131415161718\documentclass&#123;article&#125;\usepackage[T1]&#123;fontenc&#125;\usepackage[scaled=0.82]&#123;beramono&#125;\usepackage&#123;listings,xcolor&#125;\begin&#123;document&#125;\begin&#123;lstlisting&#125;[basicstyle=\small\ttfamily,language=&#123;[LaTeX]TeX&#125;, texcsstyle=*\color&#123;red&#125;\bfseries, keywordstyle=\color&#123;blue&#125;\bfseries, morekeywords=alignat,moretexcs=intertext]\begin&#123;alignat*&#125;&#123;4&#125; y &amp;= -4 &amp;+ 3 &amp;+4 &amp;-7 \\ y &amp;= &amp;+ 3 &amp; &amp;-7 \\ \intertext&#123;Therefore&#125; a &amp;= b &amp;d &amp;= cccc &amp;e &amp;= d \\ a &amp;= bbbb &amp;d &amp;= c &amp;e &amp;= d\end&#123;alignat*&#125;\end&#123;lstlisting&#125;\end&#123;document&#125; 正确的演示效果如下图所示：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[renewcommand partname 时的问题]]></title>
      <url>%2Fstylus%2F2009%2F03%2F24%2Frenewcommand-partname%2F</url>
      <content type="text"><![CDATA[在documentclass为book时解决方法如下： 123456789\documentclass[a4paper]&#123;book&#125;\usepackage&#123;ctex,CJKnumb&#125;\renewcommand\thepart&#123;&#125;\renewcommand\partname&#123;第\CJKnumber&#123;\arabic&#123;part&#125;&#125;部分&#125;\begin&#123;document&#125;\begin&#123;CJK*&#125;&#123;GBK&#125;&#123;xihei&#125;\part[asfd]&#123;test asdf&#125;asdf asdfasfd\end&#123;CJK*&#125;\end&#123;document&#125; 在documentclass为beamer时解决方法如下(该方法由黄正华老师提供，但要注意选择不同的theme时，要根据实际情况改变partpage中beamercolorbox的具体参数，换句话说，这个解决方法与上面的方法不同，它不具有通用性)： 12345678910111213141516171819202122232425\documentclass[CJK]&#123;beamer&#125;\usepackage&#123;CJK,CJKnumb&#125;\usetheme&#123;Madrid&#125;\begin&#123;document&#125;\begin&#123;CJK*&#125;&#123;GBK&#125;&#123;kai&#125;\renewcommand\partname&#123;第\CJKnumber&#123;\value&#123;part&#125;&#125;部分&#125;\defbeamertemplate*&#123;part page&#125;&#123;mypartpage&#125;[1][] &#123; \begin&#123;centering&#125; &#123; \usebeamerfont&#123;part name&#125;\usebeamercolor[fg]&#123;part name&#125;\partname&#125; \vskip1em\par \begin&#123;beamercolorbox&#125;[rounded=true,shadow=true,sep=8pt,center,#1]&#123;part title&#125; \usebeamerfont&#123;part title&#125;\insertpart\par \end&#123;beamercolorbox&#125; \end&#123;centering&#125;&#125;\setbeamertemplate&#123;part page&#125;[mypartpage][]\title&#123;test&#125;\date&#123;&#125;\part[asfd]&#123;test asdf&#125;\frame&#123;\partpage&#125;\end&#123;CJK*&#125;\end&#123;document&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[无法删除文件或文件夹的处理]]></title>
      <url>%2Fstylus%2F2009%2F03%2F03%2Fdelete-file-and-folders%2F</url>
      <content type="text"><![CDATA[在删除文件或文件夹时，Windows系统错误提示：无法删除****，找不到指定文件，请确定指定的路径及文件名是否正确的解决方法…… 经常有人会碰到这个问题，网上找了很多版本的解决方法都没有用，用一些 360 文件粉碎，优化大师粉碎也不行，但这一个方法需非常有效，一试就成功，收藏下来。 具体方法如下，请一步步进行，一定可以解决你的难题。 启用一个 cmd； 到要删除的文件(夹)的上一层目录下； 运行命令：dir /x，然后记下要删除的文件(夹)对应行的第三列(记作 比如：alixixi~com)； 如果是文件，输入：del alixixi~com(就是刚才记得东西)，是文件夹就输入：rd alixixi~com； 大功告成！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Aurora]]></title>
      <url>%2Fstylus%2F2008%2F07%2F26%2Faurora%2F</url>
      <content type="text"><![CDATA[下载地址：http://elevatorlady.ca/ 破解：http://ssfighter.blog.com.cn/archives/2007/2296454.shtml 演示： 懒人的最佳选择。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Outlook 解决找不到 Outlook.pst z]]></title>
      <url>%2Fstylus%2F2007%2F12%2F18%2FOutlook-pst%2F</url>
      <content type="text"><![CDATA[找不到文件C:\Documents and Settings\Administrator\Local Settings\Application Data\Microsoft\Outlook\Outlook.pst，要求定位该文件： 开始 –&gt; 运行 –&gt; cmd（我建议用“附件”中的“命令提示行”，因为“cmd”下可能不支持长文件名和空格路径 在DOS下，用 &quot;cd xxx&quot; 切换到 Outlook.exe 可执行文件目录下（安装目录如：C:\Program Files\Microsoft Office\OFFICE12） 使用命令 outlook /importprf .\.prf 进行初始化 Outlook 数据文件。 初始化安装 Outlook 启动时，需要新建一电子邮件帐户界面[能到这里来的基本都不打算恢复邮件了吧？呵呵- -！] PS：该命令即：outlook_/importprf_.\.prf 其中“_”即空格键！ 我在安装 Outlook Connector 时，由于网络原因，下载新版本的 Connector（OLC.msi）失败，导致 Outlook 无法打开，使用上面的方法重新创建outlook.pst文件时，提示msncon.dll找不到，解决方法就是找到最新版的 Outlook Connector（如果你的Office不是正版，用迅雷搜 Outlook Connector试试）安装后就好。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设置MATLAB中Current Folder的默认文件夹]]></title>
      <url>%2Fstylus%2F2007%2F07%2F18%2Fmatlab-current-default-folder%2F</url>
      <content type="text"><![CDATA[原文地址：http://www.yueye.org/2011/set-matlab-current-default-folder.html 在我们使用MATLAB的过程中，其Current Folder面板会给我们带来一定的便利性。但遗憾的是，MATLAB自身没有提供友好的设置界面，以供用户自如地设置Current Folder面板上的起始文件夹。这就给我们带来了一定的不便，毕竟每次启动MATLAB后都重新在Current Folder中设置到我们想要的文件夹地址会耗费一定的时间，也会影响我们的心情。 那么，我们应该如何在MATLAB中设置Current Folder面板上的起始文件夹位置呢？ 在以前的MATLAB版本中，我们可以通过右击MATLAB安装目录下MATLAB快捷方式而在其弹出的对话框中通过设置快捷方式的起始位置而对Current Folder面板上的起始文件夹进行设置。但自从MATLAB进入R2010和R2011后，我们已经不能通过这样的设置来实现我们想要的效果。但MATLAB自身提供了另一种方式，虽然不太友好，但毕竟一次设置永久受益，还是让我们来一起设置一下吧。 首先，思考选择一个你要设置的文件夹路径，比如你可以保持一贯的传统，而设置为“MATLAB\R2011a\work\”文件夹； 接着，让我们进入MATLAB的安装目录下的“MATLAB\R2011a\toolbox\local”文件夹下，在local文件夹下新建一个名为startup的.m文件，在其中输入如下内容： cd D:\Program Files\MATLAB\R2011a\work 其中cd后面的内容为你要设置的起始文件夹路径。 需要注意的是，这里的路径不需要用引号引起来，也不需要做任何处理。编写好startup.m文件并保存后，再次启动MATLAB，可以看到，MATLAB的Current Folder面板上的起始文件夹已经变成了我们设置的路径。 这里还有一点需要特别说明的是，如果你要设置的路径包含中文名，比如“D:\我的文档\MATLAB”，则在编写好如下所示的startup.m文件内容： cd D:\我的文档\MATLAB 之后，还需要将该文件的编码修改为Unicode，MATLAB才能正常识别，从而你的设置才能正常发挥作用，MATLAB启动时，Current Folder面板上的起始文件夹初始地址才能变成设置的效果。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[latex+dvipdfmx编译pgf图形无效的解决方法z]]></title>
      <url>%2Fstylus%2F2007%2F07%2F18%2Ftikz-dvipdfm-not-work%2F</url>
      <content type="text"><![CDATA[原文地址：http://bbs.ctex.org/forum.php?mod=viewthread&amp;tid=76106&amp;extra=&amp;page=1 最好的方法是升级expl3宏包 123456789101112\documentclass[cs4size,openany,twoside,UTF8]&#123;ctexbook&#125;\usepackage[]&#123;graphicx&#125;\def\pgfsysdriver&#123;pgfsys-dvipdfm.def&#125;\usepackage&#123;tikz&#125;\begin&#123;document&#125;\begin&#123;tikzpicture&#125;\draw (2,2) circle (10ex);\end&#123;tikzpicture&#125;\end&#123;document&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[多段文本分段]]></title>
      <url>%2Fstylus%2F2007%2F07%2F18%2Fregexp1%2F</url>
      <content type="text"><![CDATA[参考资料：http://www.geany.org/manual/gtk/glib/glib-regex-syntax.html 说明，只是大概思想，如果真想对一篇很长的文本分段，直接这么做肯定不行。 表达式：&lt;h1&gt;(.(?!&lt;h1&gt;))+\r\n，注意环境为.NET 2.0，设置匹配的 Options 为SingleLine。 文本1234567891011&lt;h1&gt;第一百八十一章 正文&lt;/h1&gt;&lt;p&gt;asdf&lt;/p&gt;&lt;p&gt;asdf&lt;/p&gt;&lt;p&gt;asdf&lt;/p&gt;&lt;h1&gt;第一百八十三章 正文&lt;/h1&gt;&lt;p&gt;asdf&lt;/p&gt;&lt;p&gt;asdf&lt;/p&gt;&lt;p&gt;asdf&lt;/p&gt;&lt;h1&gt;第一百八十二章 正文&lt;/h1&gt;&lt;p&gt;asdf&lt;/p&gt;&lt;p&gt;asdf&lt;/p&gt; 结果1234567891011121314151617181920(&lt;h1&gt;第一百八十一章 正文&lt;/h1&gt;&lt;p&gt;asdf&lt;/p&gt;&lt;p&gt;asdf&lt;/p&gt;&lt;p&gt;asdf&lt;/p&gt;) (&gt;)------- NEXT MATCH -------(&lt;h1&gt;第一百八十三章 正文&lt;/h1&gt;&lt;p&gt;asdf&lt;/p&gt;&lt;p&gt;asdf&lt;/p&gt;&lt;p&gt;asdf&lt;/p&gt;) (&gt;)------- NEXT MATCH -------(&lt;h1&gt;第一百八十二章 正文&lt;/h1&gt;&lt;p&gt;asdf&lt;/p&gt;&lt;p&gt;asdf&lt;/p&gt;) (&gt;)------- NEXT MATCH ------- 参考表达式string strReg=@&quot;((?&lt;!深圳市).(?!深圳市))+&quot;; 参考资料http://www.geany.org/manual/gtk/glib/glib-regex-syntax.html An assertion is a test on the characters following or preceding the current matching point that does not actually consume any characters. The simple assertions coded as \b, \B, \A, \Z, \z, ^ and $ are described above. More complicated assertions are coded as subpatterns. There are two kinds: those that look ahead of the current position in the subject string, and those that look behind it. An assertion subpattern is matched in the normal way, except that it does not cause the current matching position to be changed. Lookahead assertions start with (?= for positive assertions and (?! for negative assertions. For example, \w+(?=;) matches a word followed by a semicolon, but does not include the semicolon in the match, and foo(?!bar) matches any occurrence of &quot;foo&quot; that is not followed by &quot;bar&quot;. Note that the apparently similar pattern (?!foo)bar does not find an occurrence of &quot;bar&quot; that is preceded by something other than &quot;foo&quot;; it finds any occurrence of &quot;bar&quot; whatsoever, because the assertion (?!foo) is always TRUE when the next three characters are &quot;bar&quot;. A lookbehind assertion is needed to achieve this effect. Lookbehind assertions start with (?&lt;= for positive assertions and (?&lt;! for negative assertions. For example, (?&lt;!foo)bar does find an occurrence of &quot;bar&quot; that is not preceded by &quot;foo&quot;. The contents of a lookbehind assertion are restricted such that all the strings it matches must have a fixed length. However, if there are several alternatives, they do not all have to have the same fixed length. Thus (?&lt;=bullock|donkey) is permitted, but (?&lt;!dogs?|cats?) causes an error at compile time. Branches that match different length strings are permitted only at the top level of a lookbehind assertion. This is an extension compared with Perl 5.005, which requires all branches to match the same length of string. An assertion such as (?&lt;=ab(c|de)) is not permitted, because its single top-level branch can match two different lengths, but it is acceptable if rewritten to use two top-level branches: (?&lt;=abc|abde) The implementation of lookbehind assertions is, for each alternative, to temporarily move the current position back by the fixed width and then try to match. If there are insufficient characters before the current position, the match is deemed to fail. Lookbehinds in conjunction with once-only subpatterns can be particularly useful for matching at the ends of strings; an example is given at the end of the section on once-only subpatterns. Several assertions (of any sort) may occur in succession. For example, (?&lt;=\d{3})(?&lt;!999)foo matches &quot;foo&quot; preceded by three digits that are not &quot;999&quot;. Notice that each of the assertions is applied independently at the same point in the subject string. First there is a check that the previous three characters are all digits, then there is a check that the same three characters are not &quot;999&quot;. This pattern does not match &quot;foo&quot; preceded by six characters, the first of which are digits and the last three of which are not &quot;999&quot;. For example, it doesn&#39;t match &quot;123abcfoo&quot;. A pattern to do that is (?&lt;=\d{3}...)(?&lt;!999)foo This time the first assertion looks at the preceding six characters, checking that the first three are digits, and then the second assertion checks that the preceding three characters are not &quot;999&quot;. Assertions can be nested in any combination. For example, (?&lt;=(?&lt;!foo)bar)baz matches an occurrence of &quot;baz&quot; that is preceded by &quot;bar&quot; which in turn is not preceded by &quot;foo&quot;, while (?&lt;=\d{3}(?!999)...)foo is another pattern which matches &quot;foo&quot; preceded by three digits and any three characters that are not &quot;999&quot;. Assertion subpatterns are not capturing subpatterns, and may not be repeated, because it makes no sense to assert the same thing several times. If any kind of assertion contains capturing subpatterns within it, these are counted for the purposes of numbering the capturing subpatterns in the whole pattern. However, substring capturing is carried out only for positive assertions, because it does not make sense for negative assertions.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[几个正则表达式]]></title>
      <url>%2Fstylus%2F2007%2F07%2F18%2Fregexp%2F</url>
      <content type="text"><![CDATA[网络上的小说总是格式比较糟糕，需要进行整理才看起来舒服一些。 整理的过程中也遇到一些问题，我用的是 VS2005、C#，C# 对正则的支持很到位，甚至包含一些其它语言如 Perl 所没有的特殊功能，下面是相关表达式： 删除空行[\s ]*(?=\r\n)，要注意这个表达式中包含了一个全角的空格。在 Editplus 中还推荐了另一种写法，不过没有采用，是这样的：^[ \t]*\n（注意 \t 前有一个空格，当然愿意的话也可以和第一种一样包含一个全角空格），这种写法用C#的正则表达式测试器来测试的时候并不有效。而前一种写法在 Editplus 中则好像不能够支持，另外 Editplus 好像对?=、?!、?&lt;=、?&lt;!这几种高级部分内容的支持也不存在。 当然Editplus的最大好处之一就是能够同时替换打开的多个文件，这点真的比较有用。 双引号问题在小说中经常由于排版原因会出现““这样两个连续的起始直角双引号，这时候要注意表达式的写法，如果直接用(“.+)“这样写法会导致匹配出现错误，本来想非贪婪是否能够解决，似乎没有什么作用，只好取个巧，用下面的表达式完成：(“[^“]+)“，这个表达式 Editplus 也支持，所以效果还是不错的。 此外，Frontpage2003 对于正则也提供简单支持，只是它的语法与传统的正则语法有些出入，提供的功能也比较简单，但对于简单的工作它还是有很大作用的，配合它提供的“html代码格式重新设置”功能，可以简化许多通过程序也比较不容易完成的任务。]]></content>
    </entry>

    
  
  
</search>
